"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@openpassport";
exports.ids = ["vendor-chunks/@openpassport"];
exports.modules = {

/***/ "(ssr)/./node_modules/@openpassport/zk-kit-imt/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@openpassport/zk-kit-imt/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IMT: () => (/* binding */ IMT)\n/* harmony export */ });\n/* harmony import */ var _openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @openpassport/zk-kit-utils */ \"(ssr)/./node_modules/@openpassport/zk-kit-utils/dist/index.node.js\");\n/**\n * @module @openpassport/zk-kit-imt\n * @version 0.0.5\n * @file Incremental Merkle tree implementation in TypeScript.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://www.openpassport.app/}\n*/\n\n\n/**\n * An {@link IMT} (aka Incremental Merkle Tree) is a type of data structure used in cryptography and\n * computer science for efficiently verifying the integrity of a large set of data,\n * especially in situations where new data is added over time. It is based on the concept\n * of a Merkle tree, and its key feature is its ability to efficiently update the tree\n * when new data is added or existing data is modified.\n * In this implementation, the tree is constructed using a fixed {@link IMT#depth}\n * value, and a list of {@link IMT#zeroes} (one for each level) is used to compute the\n * hash of a node when not all of its children are defined. The number of children for each\n * node can also be specified with the {@link IMT#arity} parameter.\n */\nclass IMT {\n    /**\n     * It initializes the tree with an hash function, the depth, the zero value to use for zeroes\n     * and the arity (i.e. the number of children for each node). It also takes an optional parameter\n     * to initialize the tree with a list of leaves.\n     * @param hash The hash function used to create nodes.\n     * @param depth The tree depth.\n     * @param zeroValue The zero value used to create zeroes.\n     * @param arity The number of children for each node.\n     * @param leaves The list of initial leaves.\n     */\n    constructor(hash, depth, zeroValue, arity = 2, leaves = []) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireFunction)(hash, \"hash\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(depth, \"depth\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireTypes)(zeroValue, \"zeroValue\", [\"number\", \"string\", \"bigint\"]);\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(arity, \"arity\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireObject)(leaves, \"leaves\");\n        if (leaves.length > arity ** depth) {\n            throw new Error(`The tree cannot contain more than ${arity ** depth} leaves`);\n        }\n        // Initialize the attributes.\n        this._hash = hash;\n        this._depth = depth;\n        this._zeroes = [];\n        this._nodes = [];\n        this._arity = arity;\n        for (let level = 0; level < depth; level += 1) {\n            this._zeroes.push(zeroValue);\n            this._nodes[level] = [];\n            // There must be a zero value for each tree level (except the root).\n            zeroValue = hash(Array(this._arity).fill(zeroValue));\n        }\n        this._nodes[depth] = [];\n        // It initializes the tree with a list of leaves if there are any.\n        if (leaves.length > 0) {\n            this._nodes[0] = leaves;\n            for (let level = 0; level < depth; level += 1) {\n                for (let index = 0; index < Math.ceil(this._nodes[level].length / arity); index += 1) {\n                    const position = index * arity;\n                    const children = [];\n                    for (let i = 0; i < arity; i += 1) {\n                        children.push(this._nodes[level][position + i] ?? this.zeroes[level]);\n                    }\n                    this._nodes[level + 1][index] = hash(children);\n                }\n            }\n        }\n        else {\n            // If there are no leaves, the default root is the last zero value.\n            this._nodes[depth][0] = zeroValue;\n        }\n        // Freeze the array objects. It prevents unintentional changes.\n        Object.freeze(this._zeroes);\n        Object.freeze(this._nodes);\n    }\n    /**\n     * The root of the tree. This value doesn't need to be stored as\n     * it is always the first and unique element of the last level of the tree.\n     * Its value can be retrieved in {@link IMT#_nodes}.\n     * @returns The root hash of the tree.\n     */\n    get root() {\n        return this._nodes[this.depth][0];\n    }\n    /**\n     * The depth of the tree, which equals the number of levels - 1.\n     * @returns The depth of the tree.\n     */\n    get depth() {\n        return this._depth;\n    }\n    /**\n     * The leaves of the tree. They can be retrieved from the first\n     * level of the tree using {@link IMT#_nodes}. The returned\n     * value is a copy of the array and not the original object.\n     * @returns The list of tree leaves.\n     */\n    get leaves() {\n        return this._nodes[0].slice();\n    }\n    /**\n     * The list of zero values calculated during the initialization of the tree.\n     * @returns The list of pre-computed zeroes.\n     */\n    get zeroes() {\n        return this._zeroes;\n    }\n    /**\n     * The number of children per node.\n     * @returns The number of children per node.\n     */\n    get arity() {\n        return this._arity;\n    }\n    /**\n     * It returns the index of a leaf. If the leaf does not exist it returns -1.\n     * @param leaf A leaf of the tree.\n     * @returns The index of the leaf.\n     */\n    indexOf(leaf) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireTypes)(leaf, \"leaf\", [\"number\", \"string\", \"bigint\"]);\n        return this._nodes[0].indexOf(leaf);\n    }\n    /**\n     * The leaves are inserted incrementally. If 'i' is the index of the last\n     * leaf, the new one will be inserted at position 'i + 1'. Every time a\n     * new leaf is inserted, the nodes that separate the new leaf from the root\n     * of the tree are created or updated if they already exist, from bottom to top.\n     * When a node has only one child (the left one), its value is the hash of that\n     * node and the zero value of that level. Otherwise, the hash of the children\n     * is calculated.\n     * @param leaf The new leaf to be inserted in the tree.\n     */\n    insert(leaf) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireTypes)(leaf, \"leaf\", [\"number\", \"string\", \"bigint\"]);\n        if (this._nodes[0].length >= this.arity ** this.depth) {\n            throw new Error(\"The tree is full\");\n        }\n        let node = leaf;\n        let index = this._nodes[0].length;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this._nodes[level][index] = node;\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this._nodes[level].length) {\n                    children.push(this._nodes[level][i]);\n                }\n                else {\n                    children.push(this._zeroes[level]);\n                }\n            }\n            node = this._hash(children);\n            index = Math.floor(index / this.arity);\n        }\n        this._nodes[this.depth][0] = node;\n    }\n    /**\n     * It deletes a leaf from the tree. It does not remove the leaf from\n     * the data structure, but rather it sets the leaf to be deleted to the zero value.\n     * @param index The index of the leaf to be deleted.\n     */\n    delete(index) {\n        this.update(index, this.zeroes[0]);\n    }\n    /**\n     * It updates a leaf in the tree. It's very similar to the {@link IMT#insert} function.\n     * @param index The index of the leaf to be updated.\n     * @param newLeaf The new leaf to be inserted.\n     */\n    update(index, newLeaf) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(index, \"index\");\n        if (index < 0 || index >= this._nodes[0].length) {\n            throw new Error(\"The leaf does not exist in this tree\");\n        }\n        let node = newLeaf;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this._nodes[level][index] = node;\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this._nodes[level].length) {\n                    children.push(this._nodes[level][i]);\n                }\n                else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this._hash(children);\n            index = Math.floor(index / this.arity);\n        }\n        this._nodes[this.depth][0] = node;\n    }\n    /**\n     * It creates a {@link IMTMerkleProof} for a leaf of the tree.\n     * That proof can be verified by this tree using the same hash function.\n     * @param index The index of the leaf for which a Merkle proof will be generated.\n     * @returns The Merkle proof of the leaf.\n     */\n    createProof(index) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(index, \"index\");\n        if (index < 0 || index >= this._nodes[0].length) {\n            throw new Error(\"The leaf does not exist in this tree\");\n        }\n        const siblings = [];\n        const pathIndices = [];\n        const leafIndex = index;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            pathIndices[level] = position;\n            siblings[level] = [];\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i !== index) {\n                    if (i < this._nodes[level].length) {\n                        siblings[level].push(this._nodes[level][i]);\n                    }\n                    else {\n                        siblings[level].push(this.zeroes[level]);\n                    }\n                }\n            }\n            index = Math.floor(index / this.arity);\n        }\n        return { root: this.root, leaf: this._nodes[0][leafIndex], pathIndices, siblings, leafIndex };\n    }\n    /**\n     * It verifies a {@link IMTMerkleProof} to confirm that a leaf indeed\n     * belongs to a tree.  Does not verify that the node belongs to this\n     * tree in particular.  Equivalent to `IMT.verifyProof(proof, this._hash)`.\n     *\n     * @param proof The Merkle tree proof.\n     * @returns True if the leaf is part of the tree, and false otherwise.\n     */\n    verifyProof(proof) {\n        return IMT.verifyProof(proof, this._hash);\n    }\n    /**\n     * It verifies a {@link IMTMerkleProof} to confirm that a leaf indeed\n     * belongs to a tree.\n     * @param proof The Merkle tree proof.\n     * @param hash The hash function used to compute the tree nodes.\n     * @returns True if the leaf is part of the tree, and false otherwise.\n     */\n    static verifyProof(proof, hash) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireObject)(proof, \"proof\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireTypes)(proof.root, \"proof.root\", [\"number\", \"string\", \"bigint\"]);\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireTypes)(proof.leaf, \"proof.leaf\", [\"number\", \"string\", \"bigint\"]);\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireArray)(proof.siblings, \"proof.siblings\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireArray)(proof.pathIndices, \"proof.pathIndices\");\n        let node = proof.leaf;\n        for (let i = 0; i < proof.siblings.length; i += 1) {\n            const children = proof.siblings[i].slice();\n            children.splice(proof.pathIndices[i], 0, node);\n            node = hash(children);\n        }\n        return proof.root === node;\n    }\n    /**\n     * The whole tree.\n     * @returns The whole tree.\n     */\n    get nodes() {\n        return this._nodes;\n    }\n    /**\n     * Set the whole tree.\n     * @param nodes The new tree.\n     */\n    setNodes(nodes) {\n        this._nodes = nodes;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9wZW5wYXNzcG9ydC96ay1raXQtaW10L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDdUg7O0FBRXZIO0FBQ0EsT0FBTyxXQUFXO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyRUFBZTtBQUN2QixRQUFRLHlFQUFhO0FBQ3JCLFFBQVEsd0VBQVk7QUFDcEIsUUFBUSx5RUFBYTtBQUNyQixRQUFRLHlFQUFhO0FBQ3JCO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DLG9DQUFvQyxzREFBc0Q7QUFDMUY7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdFQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3RUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5RUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5RUFBYTtBQUNyQixRQUFRLHdFQUFZO0FBQ3BCLFFBQVEsd0VBQVk7QUFDcEIsUUFBUSx3RUFBWTtBQUNwQixRQUFRLHdFQUFZO0FBQ3BCO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZWxmLXdvcmtzaG9wLy4vbm9kZV9tb2R1bGVzL0BvcGVucGFzc3BvcnQvemsta2l0LWltdC9kaXN0L2luZGV4LmpzPzZlYjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEBvcGVucGFzc3BvcnQvemsta2l0LWltdFxuICogQHZlcnNpb24gMC4wLjVcbiAqIEBmaWxlIEluY3JlbWVudGFsIE1lcmtsZSB0cmVlIGltcGxlbWVudGF0aW9uIGluIFR5cGVTY3JpcHQuXG4gKiBAY29weXJpZ2h0IEV0aGVyZXVtIEZvdW5kYXRpb24gMjAyNFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAc2VlIFtHaXRodWJde0BsaW5rIGh0dHBzOi8vd3d3Lm9wZW5wYXNzcG9ydC5hcHAvfVxuKi9cbmltcG9ydCB7IHJlcXVpcmVGdW5jdGlvbiwgcmVxdWlyZU51bWJlciwgcmVxdWlyZVR5cGVzLCByZXF1aXJlT2JqZWN0LCByZXF1aXJlQXJyYXkgfSBmcm9tICdAb3BlbnBhc3Nwb3J0L3prLWtpdC11dGlscyc7XG5cbi8qKlxuICogQW4ge0BsaW5rIElNVH0gKGFrYSBJbmNyZW1lbnRhbCBNZXJrbGUgVHJlZSkgaXMgYSB0eXBlIG9mIGRhdGEgc3RydWN0dXJlIHVzZWQgaW4gY3J5cHRvZ3JhcGh5IGFuZFxuICogY29tcHV0ZXIgc2NpZW5jZSBmb3IgZWZmaWNpZW50bHkgdmVyaWZ5aW5nIHRoZSBpbnRlZ3JpdHkgb2YgYSBsYXJnZSBzZXQgb2YgZGF0YSxcbiAqIGVzcGVjaWFsbHkgaW4gc2l0dWF0aW9ucyB3aGVyZSBuZXcgZGF0YSBpcyBhZGRlZCBvdmVyIHRpbWUuIEl0IGlzIGJhc2VkIG9uIHRoZSBjb25jZXB0XG4gKiBvZiBhIE1lcmtsZSB0cmVlLCBhbmQgaXRzIGtleSBmZWF0dXJlIGlzIGl0cyBhYmlsaXR5IHRvIGVmZmljaWVudGx5IHVwZGF0ZSB0aGUgdHJlZVxuICogd2hlbiBuZXcgZGF0YSBpcyBhZGRlZCBvciBleGlzdGluZyBkYXRhIGlzIG1vZGlmaWVkLlxuICogSW4gdGhpcyBpbXBsZW1lbnRhdGlvbiwgdGhlIHRyZWUgaXMgY29uc3RydWN0ZWQgdXNpbmcgYSBmaXhlZCB7QGxpbmsgSU1UI2RlcHRofVxuICogdmFsdWUsIGFuZCBhIGxpc3Qgb2Yge0BsaW5rIElNVCN6ZXJvZXN9IChvbmUgZm9yIGVhY2ggbGV2ZWwpIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIGhhc2ggb2YgYSBub2RlIHdoZW4gbm90IGFsbCBvZiBpdHMgY2hpbGRyZW4gYXJlIGRlZmluZWQuIFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZm9yIGVhY2hcbiAqIG5vZGUgY2FuIGFsc28gYmUgc3BlY2lmaWVkIHdpdGggdGhlIHtAbGluayBJTVQjYXJpdHl9IHBhcmFtZXRlci5cbiAqL1xuY2xhc3MgSU1UIHtcbiAgICAvKipcbiAgICAgKiBJdCBpbml0aWFsaXplcyB0aGUgdHJlZSB3aXRoIGFuIGhhc2ggZnVuY3Rpb24sIHRoZSBkZXB0aCwgdGhlIHplcm8gdmFsdWUgdG8gdXNlIGZvciB6ZXJvZXNcbiAgICAgKiBhbmQgdGhlIGFyaXR5IChpLmUuIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZm9yIGVhY2ggbm9kZSkuIEl0IGFsc28gdGFrZXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyXG4gICAgICogdG8gaW5pdGlhbGl6ZSB0aGUgdHJlZSB3aXRoIGEgbGlzdCBvZiBsZWF2ZXMuXG4gICAgICogQHBhcmFtIGhhc2ggVGhlIGhhc2ggZnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgbm9kZXMuXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSB0cmVlIGRlcHRoLlxuICAgICAqIEBwYXJhbSB6ZXJvVmFsdWUgVGhlIHplcm8gdmFsdWUgdXNlZCB0byBjcmVhdGUgemVyb2VzLlxuICAgICAqIEBwYXJhbSBhcml0eSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGZvciBlYWNoIG5vZGUuXG4gICAgICogQHBhcmFtIGxlYXZlcyBUaGUgbGlzdCBvZiBpbml0aWFsIGxlYXZlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBkZXB0aCwgemVyb1ZhbHVlLCBhcml0eSA9IDIsIGxlYXZlcyA9IFtdKSB7XG4gICAgICAgIHJlcXVpcmVGdW5jdGlvbihoYXNoLCBcImhhc2hcIik7XG4gICAgICAgIHJlcXVpcmVOdW1iZXIoZGVwdGgsIFwiZGVwdGhcIik7XG4gICAgICAgIHJlcXVpcmVUeXBlcyh6ZXJvVmFsdWUsIFwiemVyb1ZhbHVlXCIsIFtcIm51bWJlclwiLCBcInN0cmluZ1wiLCBcImJpZ2ludFwiXSk7XG4gICAgICAgIHJlcXVpcmVOdW1iZXIoYXJpdHksIFwiYXJpdHlcIik7XG4gICAgICAgIHJlcXVpcmVPYmplY3QobGVhdmVzLCBcImxlYXZlc1wiKTtcbiAgICAgICAgaWYgKGxlYXZlcy5sZW5ndGggPiBhcml0eSAqKiBkZXB0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdHJlZSBjYW5ub3QgY29udGFpbiBtb3JlIHRoYW4gJHthcml0eSAqKiBkZXB0aH0gbGVhdmVzYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgYXR0cmlidXRlcy5cbiAgICAgICAgdGhpcy5faGFzaCA9IGhhc2g7XG4gICAgICAgIHRoaXMuX2RlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMuX3plcm9lcyA9IFtdO1xuICAgICAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLl9hcml0eSA9IGFyaXR5O1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3plcm9lcy5wdXNoKHplcm9WYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1tsZXZlbF0gPSBbXTtcbiAgICAgICAgICAgIC8vIFRoZXJlIG11c3QgYmUgYSB6ZXJvIHZhbHVlIGZvciBlYWNoIHRyZWUgbGV2ZWwgKGV4Y2VwdCB0aGUgcm9vdCkuXG4gICAgICAgICAgICB6ZXJvVmFsdWUgPSBoYXNoKEFycmF5KHRoaXMuX2FyaXR5KS5maWxsKHplcm9WYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25vZGVzW2RlcHRoXSA9IFtdO1xuICAgICAgICAvLyBJdCBpbml0aWFsaXplcyB0aGUgdHJlZSB3aXRoIGEgbGlzdCBvZiBsZWF2ZXMgaWYgdGhlcmUgYXJlIGFueS5cbiAgICAgICAgaWYgKGxlYXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1swXSA9IGxlYXZlcztcbiAgICAgICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCBkZXB0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBNYXRoLmNlaWwodGhpcy5fbm9kZXNbbGV2ZWxdLmxlbmd0aCAvIGFyaXR5KTsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGluZGV4ICogYXJpdHk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJpdHk7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLl9ub2Rlc1tsZXZlbF1bcG9zaXRpb24gKyBpXSA/PyB0aGlzLnplcm9lc1tsZXZlbF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vZGVzW2xldmVsICsgMV1baW5kZXhdID0gaGFzaChjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGxlYXZlcywgdGhlIGRlZmF1bHQgcm9vdCBpcyB0aGUgbGFzdCB6ZXJvIHZhbHVlLlxuICAgICAgICAgICAgdGhpcy5fbm9kZXNbZGVwdGhdWzBdID0gemVyb1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZyZWV6ZSB0aGUgYXJyYXkgb2JqZWN0cy4gSXQgcHJldmVudHMgdW5pbnRlbnRpb25hbCBjaGFuZ2VzLlxuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMuX3plcm9lcyk7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcy5fbm9kZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcm9vdCBvZiB0aGUgdHJlZS4gVGhpcyB2YWx1ZSBkb2Vzbid0IG5lZWQgdG8gYmUgc3RvcmVkIGFzXG4gICAgICogaXQgaXMgYWx3YXlzIHRoZSBmaXJzdCBhbmQgdW5pcXVlIGVsZW1lbnQgb2YgdGhlIGxhc3QgbGV2ZWwgb2YgdGhlIHRyZWUuXG4gICAgICogSXRzIHZhbHVlIGNhbiBiZSByZXRyaWV2ZWQgaW4ge0BsaW5rIElNVCNfbm9kZXN9LlxuICAgICAqIEByZXR1cm5zIFRoZSByb290IGhhc2ggb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1t0aGlzLmRlcHRoXVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRlcHRoIG9mIHRoZSB0cmVlLCB3aGljaCBlcXVhbHMgdGhlIG51bWJlciBvZiBsZXZlbHMgLSAxLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZXB0aCBvZiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBnZXQgZGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXB0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxlYXZlcyBvZiB0aGUgdHJlZS4gVGhleSBjYW4gYmUgcmV0cmlldmVkIGZyb20gdGhlIGZpcnN0XG4gICAgICogbGV2ZWwgb2YgdGhlIHRyZWUgdXNpbmcge0BsaW5rIElNVCNfbm9kZXN9LiBUaGUgcmV0dXJuZWRcbiAgICAgKiB2YWx1ZSBpcyBhIGNvcHkgb2YgdGhlIGFycmF5IGFuZCBub3QgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbGlzdCBvZiB0cmVlIGxlYXZlcy5cbiAgICAgKi9cbiAgICBnZXQgbGVhdmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF0uc2xpY2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgemVybyB2YWx1ZXMgY2FsY3VsYXRlZCBkdXJpbmcgdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSB0cmVlLlxuICAgICAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIHByZS1jb21wdXRlZCB6ZXJvZXMuXG4gICAgICovXG4gICAgZ2V0IHplcm9lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3plcm9lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBjaGlsZHJlbiBwZXIgbm9kZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIHBlciBub2RlLlxuICAgICAqL1xuICAgIGdldCBhcml0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FyaXR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCByZXR1cm5zIHRoZSBpbmRleCBvZiBhIGxlYWYuIElmIHRoZSBsZWFmIGRvZXMgbm90IGV4aXN0IGl0IHJldHVybnMgLTEuXG4gICAgICogQHBhcmFtIGxlYWYgQSBsZWFmIG9mIHRoZSB0cmVlLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgbGVhZi5cbiAgICAgKi9cbiAgICBpbmRleE9mKGxlYWYpIHtcbiAgICAgICAgcmVxdWlyZVR5cGVzKGxlYWYsIFwibGVhZlwiLCBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIiwgXCJiaWdpbnRcIl0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF0uaW5kZXhPZihsZWFmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxlYXZlcyBhcmUgaW5zZXJ0ZWQgaW5jcmVtZW50YWxseS4gSWYgJ2knIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdFxuICAgICAqIGxlYWYsIHRoZSBuZXcgb25lIHdpbGwgYmUgaW5zZXJ0ZWQgYXQgcG9zaXRpb24gJ2kgKyAxJy4gRXZlcnkgdGltZSBhXG4gICAgICogbmV3IGxlYWYgaXMgaW5zZXJ0ZWQsIHRoZSBub2RlcyB0aGF0IHNlcGFyYXRlIHRoZSBuZXcgbGVhZiBmcm9tIHRoZSByb290XG4gICAgICogb2YgdGhlIHRyZWUgYXJlIGNyZWF0ZWQgb3IgdXBkYXRlZCBpZiB0aGV5IGFscmVhZHkgZXhpc3QsIGZyb20gYm90dG9tIHRvIHRvcC5cbiAgICAgKiBXaGVuIGEgbm9kZSBoYXMgb25seSBvbmUgY2hpbGQgKHRoZSBsZWZ0IG9uZSksIGl0cyB2YWx1ZSBpcyB0aGUgaGFzaCBvZiB0aGF0XG4gICAgICogbm9kZSBhbmQgdGhlIHplcm8gdmFsdWUgb2YgdGhhdCBsZXZlbC4gT3RoZXJ3aXNlLCB0aGUgaGFzaCBvZiB0aGUgY2hpbGRyZW5cbiAgICAgKiBpcyBjYWxjdWxhdGVkLlxuICAgICAqIEBwYXJhbSBsZWFmIFRoZSBuZXcgbGVhZiB0byBiZSBpbnNlcnRlZCBpbiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBpbnNlcnQobGVhZikge1xuICAgICAgICByZXF1aXJlVHlwZXMobGVhZiwgXCJsZWFmXCIsIFtcIm51bWJlclwiLCBcInN0cmluZ1wiLCBcImJpZ2ludFwiXSk7XG4gICAgICAgIGlmICh0aGlzLl9ub2Rlc1swXS5sZW5ndGggPj0gdGhpcy5hcml0eSAqKiB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdHJlZSBpcyBmdWxsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gbGVhZjtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fbm9kZXNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGhpcy5kZXB0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBpbmRleCAlIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBsZXZlbFN0YXJ0SW5kZXggPSBpbmRleCAtIHBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxFbmRJbmRleCA9IGxldmVsU3RhcnRJbmRleCArIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbbGV2ZWxdW2luZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWxTdGFydEluZGV4OyBpIDwgbGV2ZWxFbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLl9ub2Rlc1tsZXZlbF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5fbm9kZXNbbGV2ZWxdW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5femVyb2VzW2xldmVsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuX2hhc2goY2hpbGRyZW4pO1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXNbdGhpcy5kZXB0aF1bMF0gPSBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCBkZWxldGVzIGEgbGVhZiBmcm9tIHRoZSB0cmVlLiBJdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxlYWYgZnJvbVxuICAgICAqIHRoZSBkYXRhIHN0cnVjdHVyZSwgYnV0IHJhdGhlciBpdCBzZXRzIHRoZSBsZWFmIHRvIGJlIGRlbGV0ZWQgdG8gdGhlIHplcm8gdmFsdWUuXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbGVhZiB0byBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShpbmRleCkge1xuICAgICAgICB0aGlzLnVwZGF0ZShpbmRleCwgdGhpcy56ZXJvZXNbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCB1cGRhdGVzIGEgbGVhZiBpbiB0aGUgdHJlZS4gSXQncyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIHtAbGluayBJTVQjaW5zZXJ0fSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBsZWFmIHRvIGJlIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIG5ld0xlYWYgVGhlIG5ldyBsZWFmIHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIHVwZGF0ZShpbmRleCwgbmV3TGVhZikge1xuICAgICAgICByZXF1aXJlTnVtYmVyKGluZGV4LCBcImluZGV4XCIpO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX25vZGVzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxlYWYgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyB0cmVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gbmV3TGVhZjtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggJSB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxTdGFydEluZGV4ID0gaW5kZXggLSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRW5kSW5kZXggPSBsZXZlbFN0YXJ0SW5kZXggKyB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzW2xldmVsXVtpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxldmVsU3RhcnRJbmRleDsgaSA8IGxldmVsRW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgdGhpcy5fbm9kZXNbbGV2ZWxdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuX25vZGVzW2xldmVsXVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuemVyb2VzW2xldmVsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuX2hhc2goY2hpbGRyZW4pO1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXNbdGhpcy5kZXB0aF1bMF0gPSBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCBjcmVhdGVzIGEge0BsaW5rIElNVE1lcmtsZVByb29mfSBmb3IgYSBsZWFmIG9mIHRoZSB0cmVlLlxuICAgICAqIFRoYXQgcHJvb2YgY2FuIGJlIHZlcmlmaWVkIGJ5IHRoaXMgdHJlZSB1c2luZyB0aGUgc2FtZSBoYXNoIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGxlYWYgZm9yIHdoaWNoIGEgTWVya2xlIHByb29mIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBNZXJrbGUgcHJvb2Ygb2YgdGhlIGxlYWYuXG4gICAgICovXG4gICAgY3JlYXRlUHJvb2YoaW5kZXgpIHtcbiAgICAgICAgcmVxdWlyZU51bWJlcihpbmRleCwgXCJpbmRleFwiKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9ub2Rlc1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsZWFmIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgdHJlZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFtdO1xuICAgICAgICBjb25zdCBwYXRoSW5kaWNlcyA9IFtdO1xuICAgICAgICBjb25zdCBsZWFmSW5kZXggPSBpbmRleDtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggJSB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxTdGFydEluZGV4ID0gaW5kZXggLSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRW5kSW5kZXggPSBsZXZlbFN0YXJ0SW5kZXggKyB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgcGF0aEluZGljZXNbbGV2ZWxdID0gcG9zaXRpb247XG4gICAgICAgICAgICBzaWJsaW5nc1tsZXZlbF0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZXZlbFN0YXJ0SW5kZXg7IGkgPCBsZXZlbEVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLl9ub2Rlc1tsZXZlbF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nc1tsZXZlbF0ucHVzaCh0aGlzLl9ub2Rlc1tsZXZlbF1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZ3NbbGV2ZWxdLnB1c2godGhpcy56ZXJvZXNbbGV2ZWxdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuYXJpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJvb3Q6IHRoaXMucm9vdCwgbGVhZjogdGhpcy5fbm9kZXNbMF1bbGVhZkluZGV4XSwgcGF0aEluZGljZXMsIHNpYmxpbmdzLCBsZWFmSW5kZXggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQgdmVyaWZpZXMgYSB7QGxpbmsgSU1UTWVya2xlUHJvb2Z9IHRvIGNvbmZpcm0gdGhhdCBhIGxlYWYgaW5kZWVkXG4gICAgICogYmVsb25ncyB0byBhIHRyZWUuICBEb2VzIG5vdCB2ZXJpZnkgdGhhdCB0aGUgbm9kZSBiZWxvbmdzIHRvIHRoaXNcbiAgICAgKiB0cmVlIGluIHBhcnRpY3VsYXIuICBFcXVpdmFsZW50IHRvIGBJTVQudmVyaWZ5UHJvb2YocHJvb2YsIHRoaXMuX2hhc2gpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9vZiBUaGUgTWVya2xlIHRyZWUgcHJvb2YuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbGVhZiBpcyBwYXJ0IG9mIHRoZSB0cmVlLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHZlcmlmeVByb29mKHByb29mKSB7XG4gICAgICAgIHJldHVybiBJTVQudmVyaWZ5UHJvb2YocHJvb2YsIHRoaXMuX2hhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCB2ZXJpZmllcyBhIHtAbGluayBJTVRNZXJrbGVQcm9vZn0gdG8gY29uZmlybSB0aGF0IGEgbGVhZiBpbmRlZWRcbiAgICAgKiBiZWxvbmdzIHRvIGEgdHJlZS5cbiAgICAgKiBAcGFyYW0gcHJvb2YgVGhlIE1lcmtsZSB0cmVlIHByb29mLlxuICAgICAqIEBwYXJhbSBoYXNoIFRoZSBoYXNoIGZ1bmN0aW9uIHVzZWQgdG8gY29tcHV0ZSB0aGUgdHJlZSBub2Rlcy5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBsZWFmIGlzIHBhcnQgb2YgdGhlIHRyZWUsIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhdGljIHZlcmlmeVByb29mKHByb29mLCBoYXNoKSB7XG4gICAgICAgIHJlcXVpcmVPYmplY3QocHJvb2YsIFwicHJvb2ZcIik7XG4gICAgICAgIHJlcXVpcmVUeXBlcyhwcm9vZi5yb290LCBcInByb29mLnJvb3RcIiwgW1wibnVtYmVyXCIsIFwic3RyaW5nXCIsIFwiYmlnaW50XCJdKTtcbiAgICAgICAgcmVxdWlyZVR5cGVzKHByb29mLmxlYWYsIFwicHJvb2YubGVhZlwiLCBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIiwgXCJiaWdpbnRcIl0pO1xuICAgICAgICByZXF1aXJlQXJyYXkocHJvb2Yuc2libGluZ3MsIFwicHJvb2Yuc2libGluZ3NcIik7XG4gICAgICAgIHJlcXVpcmVBcnJheShwcm9vZi5wYXRoSW5kaWNlcywgXCJwcm9vZi5wYXRoSW5kaWNlc1wiKTtcbiAgICAgICAgbGV0IG5vZGUgPSBwcm9vZi5sZWFmO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb29mLnNpYmxpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHByb29mLnNpYmxpbmdzW2ldLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UocHJvb2YucGF0aEluZGljZXNbaV0sIDAsIG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IGhhc2goY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9vZi5yb290ID09PSBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgd2hvbGUgdHJlZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgd2hvbGUgdHJlZS5cbiAgICAgKi9cbiAgICBnZXQgbm9kZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB3aG9sZSB0cmVlLlxuICAgICAqIEBwYXJhbSBub2RlcyBUaGUgbmV3IHRyZWUuXG4gICAgICovXG4gICAgc2V0Tm9kZXMobm9kZXMpIHtcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBub2RlcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IElNVCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@openpassport/zk-kit-imt/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@openpassport/zk-kit-lean-imt/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@openpassport/zk-kit-lean-imt/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LeanIMT: () => (/* binding */ LeanIMT)\n/* harmony export */ });\n/* harmony import */ var _openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @openpassport/zk-kit-utils */ \"(ssr)/./node_modules/@openpassport/zk-kit-utils/dist/index.node.js\");\n/**\n * @module @openpassport/zk-kit-lean-imt\n * @version 0.0.6\n * @file Lean Incremental Merkle tree implementation in TypeScript.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://www.openpassport.app/}\n*/\n\n\n/**\n * The {@link LeanIMT} is an optimized binary version of the {@link IMT}.\n * This implementation exclusively supports binary trees, eliminates the use of\n * zeroes, and the tree's {@link LeanIMT#depth} is dynamic. When a node doesn't have the right child,\n * instead of using a zero hash as in the IMT, the node's value becomes that\n * of its left child. Furthermore, rather than utilizing a static tree depth,\n * it is updated based on the number of {@link LeanIMT#leaves} in the tree. This approach\n * results in the calculation of significantly fewer hashes, making the tree more efficient.\n */\nclass LeanIMT {\n    /**\n     * It initializes the tree with a given hash function and an optional list of leaves.\n     * @param hash The hash function used to create nodes.\n     * @param leaves The list of leaves.\n     */\n    constructor(hash, leaves = []) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(hash, \"hash\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireFunction)(hash, \"hash\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireArray)(leaves, \"leaves\");\n        // Initialize the attributes.\n        this._nodes = [[]];\n        this._hash = hash;\n        // Initialize the tree with a list of leaves if there are any.\n        if (leaves.length > 0) {\n            this.insertMany(leaves);\n        }\n    }\n    /**\n     * The root of the tree. This value doesn't need to be stored as\n     * it is always the first and unique element of the last level of the tree.\n     * Its value can be retrieved in {@link LeanIMT#_nodes}.\n     * @returns The root hash of the tree.\n     */\n    get root() {\n        return this._nodes[this.depth][0];\n    }\n    /**\n     * The depth of the tree, which equals the number of levels - 1.\n     * @returns The depth of the tree.\n     */\n    get depth() {\n        return this._nodes.length - 1;\n    }\n    /**\n     * The leaves of the tree. They can be retrieved from the first\n     * level of the tree using {@link LeanIMT#_nodes}. The returned\n     * value is a copy of the array and not the original object.\n     * @returns The list of tree leaves.\n     */\n    get leaves() {\n        return this._nodes[0].slice();\n    }\n    /**\n     * The size of the tree, which the number of its leaves.\n     * It's the length of the first level's list.\n     * @returns The number of leaves of the tree.\n     */\n    get size() {\n        return this._nodes[0].length;\n    }\n    /**\n     * It returns the index of a leaf. If the leaf does not exist it returns -1.\n     * @param leaf A leaf of the tree.\n     * @returns The index of the leaf.\n     */\n    indexOf(leaf) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(leaf, \"leaf\");\n        return this._nodes[0].indexOf(leaf);\n    }\n    /**\n     * It returns true if the leaf exists, and false otherwise\n     * @param leaf A leaf of the tree.\n     * @returns True if the tree has the leaf, and false otherwise.\n     */\n    has(leaf) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(leaf, \"leaf\");\n        return this._nodes[0].includes(leaf);\n    }\n    /**\n     * The leaves are inserted incrementally. If 'i' is the index of the last\n     * leaf, the new one will be inserted at position 'i + 1'. Every time a\n     * new leaf is inserted, the nodes that separate the new leaf from the root\n     * of the tree are created or updated if they already exist, from bottom to top.\n     * When a node has only one child (the left one), its value takes on the value\n     * of the child. Otherwise, the hash of the children is calculated.\n     * @param leaf The new leaf to be inserted in the tree.\n     */\n    insert(leaf) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(leaf, \"leaf\");\n        // If the next depth is greater, a new tree level will be added.\n        if (this.depth < Math.ceil(Math.log2(this.size + 1))) {\n            // Adding an array is like adding a new level.\n            this._nodes.push([]);\n        }\n        let node = leaf;\n        // The index of the new leaf equals the number of leaves in the tree.\n        let index = this.size;\n        for (let level = 0; level < this.depth; level += 1) {\n            this._nodes[level][index] = node;\n            // Bitwise AND, 0 -> left or 1 -> right.\n            // If the node is a right node the parent node will be the hash\n            // of the child nodes. Otherwise, parent will equal left child node.\n            if (index & 1) {\n                const sibling = this._nodes[level][index - 1];\n                node = this._hash(sibling, node);\n            }\n            // Right shift, it divides a number by 2 and discards the remainder.\n            index >>= 1;\n        }\n        // Store the new root.\n        this._nodes[this.depth] = [node];\n    }\n    /**\n     * This function is useful when you want to insert N leaves all at once.\n     * It is more efficient than using the {@link LeanIMT#insert} method N times because it\n     * significantly reduces the number of cases where a node has only one\n     * child, which is a common occurrence in gradual insertion.\n     * @param leaves The list of leaves to be inserted.\n     */\n    insertMany(leaves) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(leaves, \"leaves\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireArray)(leaves, \"leaves\");\n        if (leaves.length === 0) {\n            throw new Error(\"There are no leaves to add\");\n        }\n        let startIndex = this.size >> 1;\n        this._nodes[0].push(...leaves);\n        // Calculate how many tree levels will need to be added\n        // using the number of leaves.\n        const numberOfNewLevels = Math.ceil(Math.log2(this.size)) - this.depth;\n        // Add the new levels.\n        for (let i = 0; i < numberOfNewLevels; i += 1) {\n            this._nodes.push([]);\n        }\n        for (let level = 0; level < this.depth; level += 1) {\n            // Calculate the number of nodes of the next level.\n            const numberOfNodes = Math.ceil(this._nodes[level].length / 2);\n            for (let index = startIndex; index < numberOfNodes; index += 1) {\n                const rightNode = this._nodes[level][index * 2 + 1];\n                const leftNode = this._nodes[level][index * 2];\n                const parentNode = rightNode ? this._hash(leftNode, rightNode) : leftNode;\n                this._nodes[level + 1][index] = parentNode;\n            }\n            startIndex >>= 1;\n        }\n    }\n    /**\n     * It updates a leaf in the tree. It's very similar to the {@link LeanIMT#insert} function.\n     * @param index The index of the leaf to be updated.\n     * @param newLeaf The new leaf to be inserted.\n     */\n    update(index, newLeaf) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(index, \"index\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(newLeaf, \"newLeaf\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(index, \"index\");\n        let node = newLeaf;\n        for (let level = 0; level < this.depth; level += 1) {\n            this._nodes[level][index] = node;\n            if (index & 1) {\n                const sibling = this._nodes[level][index - 1];\n                node = this._hash(sibling, node);\n            }\n            else {\n                // In this case there could still be a right node\n                // because the path might not be the rightmost one\n                // (like the 'insert' function).\n                const sibling = this._nodes[level][index + 1];\n                if (sibling) {\n                    node = this._hash(node, sibling);\n                }\n            }\n            index >>= 1;\n        }\n        this._nodes[this.depth] = [node];\n    }\n    /**\n     * Updates m leaves all at once.\n     * It is more efficient than using the {@link LeanIMT#update} method m times because it\n     * prevents updating middle nodes several times. This would happen when updating leaves\n     * with common ancestors. The naive approach of calling 'update' m times has complexity\n     * O(m*log(n)) (where n is the number of leaves of the tree), which ends up in\n     * O(n*log(n)) when m ~ n. With this new approach, this ends up being O(n) because every\n     * node is updated at most once and there are around 2*n nodes in the tree.\n     * @param indices The list of indices of the respective leaves.\n     * @param leaves The list of leaves to be updated.\n     */\n    updateMany(indices, leaves) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(leaves, \"leaves\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(indices, \"indices\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireArray)(leaves, \"leaves\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireArray)(indices, \"indices\");\n        if (leaves.length !== indices.length) {\n            throw new Error(\"There is no correspondence between indices and leaves\");\n        }\n        // This will keep track of the outdated nodes of each level.\n        let modifiedIndices = new Set();\n        for (let i = 0; i < indices.length; i += 1) {\n            (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(indices[i], `index ${i}`);\n            if (indices[i] < 0 || indices[i] >= this.size) {\n                throw new Error(`Index ${i} is out of range`);\n            }\n            if (modifiedIndices.has(indices[i])) {\n                throw new Error(`Leaf ${indices[i]} is repeated`);\n            }\n            modifiedIndices.add(indices[i]);\n        }\n        modifiedIndices.clear();\n        // First, modify the first level, which consists only of raw, un-hashed values\n        for (let leaf = 0; leaf < indices.length; leaf += 1) {\n            this._nodes[0][indices[leaf]] = leaves[leaf];\n            modifiedIndices.add(indices[leaf] >> 1);\n        }\n        // Now update each node of the corresponding levels\n        for (let level = 1; level <= this.depth; level += 1) {\n            const newModifiedIndices = [];\n            for (const index of modifiedIndices) {\n                const leftChild = this._nodes[level - 1][2 * index];\n                const rightChild = this._nodes[level - 1][2 * index + 1];\n                this._nodes[level][index] = rightChild ? this._hash(leftChild, rightChild) : leftChild;\n                newModifiedIndices.push(index >> 1);\n            }\n            modifiedIndices = new Set(newModifiedIndices);\n        }\n    }\n    /**\n     * It generates a {@link LeanIMTMerkleProof} for a leaf of the tree.\n     * That proof can be verified by this tree using the same hash function.\n     * @param index The index of the leaf for which a Merkle proof will be generated.\n     * @returns The Merkle proof of the leaf.\n     */\n    generateProof(index) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(index, \"index\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(index, \"index\");\n        if (index < 0 || index >= this.size) {\n            throw new Error(`The leaf at index '${index}' does not exist in this tree`);\n        }\n        const leaf = this.leaves[index];\n        const siblings = [];\n        const path = [];\n        for (let level = 0; level < this.depth; level += 1) {\n            const isRightNode = index & 1;\n            const siblingIndex = isRightNode ? index - 1 : index + 1;\n            const sibling = this._nodes[level][siblingIndex];\n            // If the sibling node does not exist, it means that the node at\n            // this level has the same value as its child. Therefore, there\n            // is no need to include it in the proof since there is no hash to calculate.\n            if (sibling !== undefined) {\n                path.push(isRightNode);\n                siblings.push(sibling);\n            }\n            index >>= 1;\n        }\n        // The index might be different from the original index of the leaf, since\n        // in some cases some siblings are not included (as explained above).\n        return { root: this.root, leaf, index: Number.parseInt(path.reverse().join(\"\"), 2), siblings };\n    }\n    /**\n     * It verifies a {@link LeanIMTMerkleProof} to confirm that a leaf indeed\n     * belongs to a tree.  Does not verify that the node belongs to this\n     * tree in particular.  Equivalent to\n     * `LeanIMT.verifyProof(proof, this._hash)`.\n     * @param proof The Merkle tree proof.\n     * @returns True if the leaf is part of the tree, and false otherwise.\n     */\n    verifyProof(proof) {\n        return LeanIMT.verifyProof(proof, this._hash);\n    }\n    /**\n     * It verifies a {@link LeanIMTMerkleProof} to confirm that a leaf indeed\n     * belongs to a tree.\n     * @param proof The Merkle tree proof.\n     * @returns True if the leaf is part of the tree, and false otherwise.\n     */\n    static verifyProof(proof, hash) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(proof, \"proof\");\n        const { root, leaf, siblings, index } = proof;\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(proof.root, \"proof.root\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(proof.leaf, \"proof.leaf\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(proof.siblings, \"proof.siblings\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(proof.index, \"proof.index\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireArray)(proof.siblings, \"proof.siblings\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(proof.index, \"proof.index\");\n        let node = leaf;\n        for (let i = 0; i < siblings.length; i += 1) {\n            if ((index >> i) & 1) {\n                node = hash(siblings[i], node);\n            }\n            else {\n                node = hash(node, siblings[i]);\n            }\n        }\n        return root === node;\n    }\n    /**\n     * It enables the conversion of the full tree structure into a JSON string,\n     * facilitating future imports of the tree. This approach is beneficial for\n     * large trees, as it saves time by storing hashes instead of recomputing them\n     * @returns The stringified JSON of the tree.\n     */\n    export() {\n        return JSON.stringify(this._nodes, (_, v) => (typeof v === \"bigint\" ? v.toString() : v));\n    }\n    /**\n     * It imports an entire tree by initializing the nodes without calculating\n     * any hashes. Note that it is crucial to ensure the integrity of the tree\n     * before or after importing it. If the map function is not defined, node\n     * values will be converted to bigints by default.\n     * @param hash The hash function used to create nodes.\n     * @param nodes The stringified JSON of the tree.\n     * @param map A function to map each node of the tree and convert their types.\n     * @returns A LeanIMT instance.\n     */\n    static import(hash, nodes, map) {\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(hash, \"hash\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(nodes, \"nodes\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireFunction)(hash, \"hash\");\n        (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireString)(nodes, \"nodes\");\n        if (map) {\n            (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(map, \"map\");\n            (0,_openpassport_zk_kit_utils__WEBPACK_IMPORTED_MODULE_0__.requireFunction)(map, \"map\");\n        }\n        const tree = new LeanIMT(hash);\n        tree._nodes = JSON.parse(nodes, (_, value) => {\n            if (typeof value === \"string\") {\n                return map ? map(value) : BigInt(value);\n            }\n            return value;\n        });\n        return tree;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9wZW5wYXNzcG9ydC96ay1raXQtbGVhbi1pbXQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUN5SDs7QUFFekg7QUFDQSxRQUFRLGVBQWUsdUNBQXVDLFVBQVU7QUFDeEU7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEVBQWM7QUFDdEIsUUFBUSwyRUFBZTtBQUN2QixRQUFRLHdFQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBFQUFjO0FBQ3RCLFFBQVEsd0VBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usc0JBQXNCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwRUFBYztBQUN0QixRQUFRLDBFQUFjO0FBQ3RCLFFBQVEseUVBQWE7QUFDckI7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEVBQWM7QUFDdEIsUUFBUSwwRUFBYztBQUN0QixRQUFRLHdFQUFZO0FBQ3BCLFFBQVEsd0VBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsWUFBWSx5RUFBYSxzQkFBc0IsRUFBRTtBQUNqRDtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEVBQWM7QUFDdEIsUUFBUSx5RUFBYTtBQUNyQjtBQUNBLGtEQUFrRCxNQUFNO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwRUFBYztBQUN0QixnQkFBZ0IsOEJBQThCO0FBQzlDLFFBQVEsMEVBQWM7QUFDdEIsUUFBUSwwRUFBYztBQUN0QixRQUFRLDBFQUFjO0FBQ3RCLFFBQVEsMEVBQWM7QUFDdEIsUUFBUSx3RUFBWTtBQUNwQixRQUFRLHlFQUFhO0FBQ3JCO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwRUFBYztBQUN0QixRQUFRLDBFQUFjO0FBQ3RCLFFBQVEsMkVBQWU7QUFDdkIsUUFBUSx5RUFBYTtBQUNyQjtBQUNBLFlBQVksMEVBQWM7QUFDMUIsWUFBWSwyRUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VsZi13b3Jrc2hvcC8uL25vZGVfbW9kdWxlcy9Ab3BlbnBhc3Nwb3J0L3prLWtpdC1sZWFuLWltdC9kaXN0L2luZGV4LmpzPzIzMDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEBvcGVucGFzc3BvcnQvemsta2l0LWxlYW4taW10XG4gKiBAdmVyc2lvbiAwLjAuNlxuICogQGZpbGUgTGVhbiBJbmNyZW1lbnRhbCBNZXJrbGUgdHJlZSBpbXBsZW1lbnRhdGlvbiBpbiBUeXBlU2NyaXB0LlxuICogQGNvcHlyaWdodCBFdGhlcmV1bSBGb3VuZGF0aW9uIDIwMjRcbiAqIEBsaWNlbnNlIE1JVFxuICogQHNlZSBbR2l0aHViXXtAbGluayBodHRwczovL3d3dy5vcGVucGFzc3BvcnQuYXBwL31cbiovXG5pbXBvcnQgeyByZXF1aXJlRGVmaW5lZCwgcmVxdWlyZUZ1bmN0aW9uLCByZXF1aXJlQXJyYXksIHJlcXVpcmVOdW1iZXIsIHJlcXVpcmVTdHJpbmcgfSBmcm9tICdAb3BlbnBhc3Nwb3J0L3prLWtpdC11dGlscyc7XG5cbi8qKlxuICogVGhlIHtAbGluayBMZWFuSU1UfSBpcyBhbiBvcHRpbWl6ZWQgYmluYXJ5IHZlcnNpb24gb2YgdGhlIHtAbGluayBJTVR9LlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBleGNsdXNpdmVseSBzdXBwb3J0cyBiaW5hcnkgdHJlZXMsIGVsaW1pbmF0ZXMgdGhlIHVzZSBvZlxuICogemVyb2VzLCBhbmQgdGhlIHRyZWUncyB7QGxpbmsgTGVhbklNVCNkZXB0aH0gaXMgZHluYW1pYy4gV2hlbiBhIG5vZGUgZG9lc24ndCBoYXZlIHRoZSByaWdodCBjaGlsZCxcbiAqIGluc3RlYWQgb2YgdXNpbmcgYSB6ZXJvIGhhc2ggYXMgaW4gdGhlIElNVCwgdGhlIG5vZGUncyB2YWx1ZSBiZWNvbWVzIHRoYXRcbiAqIG9mIGl0cyBsZWZ0IGNoaWxkLiBGdXJ0aGVybW9yZSwgcmF0aGVyIHRoYW4gdXRpbGl6aW5nIGEgc3RhdGljIHRyZWUgZGVwdGgsXG4gKiBpdCBpcyB1cGRhdGVkIGJhc2VkIG9uIHRoZSBudW1iZXIgb2Yge0BsaW5rIExlYW5JTVQjbGVhdmVzfSBpbiB0aGUgdHJlZS4gVGhpcyBhcHByb2FjaFxuICogcmVzdWx0cyBpbiB0aGUgY2FsY3VsYXRpb24gb2Ygc2lnbmlmaWNhbnRseSBmZXdlciBoYXNoZXMsIG1ha2luZyB0aGUgdHJlZSBtb3JlIGVmZmljaWVudC5cbiAqL1xuY2xhc3MgTGVhbklNVCB7XG4gICAgLyoqXG4gICAgICogSXQgaW5pdGlhbGl6ZXMgdGhlIHRyZWUgd2l0aCBhIGdpdmVuIGhhc2ggZnVuY3Rpb24gYW5kIGFuIG9wdGlvbmFsIGxpc3Qgb2YgbGVhdmVzLlxuICAgICAqIEBwYXJhbSBoYXNoIFRoZSBoYXNoIGZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIG5vZGVzLlxuICAgICAqIEBwYXJhbSBsZWF2ZXMgVGhlIGxpc3Qgb2YgbGVhdmVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIGxlYXZlcyA9IFtdKSB7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKGhhc2gsIFwiaGFzaFwiKTtcbiAgICAgICAgcmVxdWlyZUZ1bmN0aW9uKGhhc2gsIFwiaGFzaFwiKTtcbiAgICAgICAgcmVxdWlyZUFycmF5KGxlYXZlcywgXCJsZWF2ZXNcIik7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGF0dHJpYnV0ZXMuXG4gICAgICAgIHRoaXMuX25vZGVzID0gW1tdXTtcbiAgICAgICAgdGhpcy5faGFzaCA9IGhhc2g7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHRyZWUgd2l0aCBhIGxpc3Qgb2YgbGVhdmVzIGlmIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIGlmIChsZWF2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRNYW55KGxlYXZlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJvb3Qgb2YgdGhlIHRyZWUuIFRoaXMgdmFsdWUgZG9lc24ndCBuZWVkIHRvIGJlIHN0b3JlZCBhc1xuICAgICAqIGl0IGlzIGFsd2F5cyB0aGUgZmlyc3QgYW5kIHVuaXF1ZSBlbGVtZW50IG9mIHRoZSBsYXN0IGxldmVsIG9mIHRoZSB0cmVlLlxuICAgICAqIEl0cyB2YWx1ZSBjYW4gYmUgcmV0cmlldmVkIGluIHtAbGluayBMZWFuSU1UI19ub2Rlc30uXG4gICAgICogQHJldHVybnMgVGhlIHJvb3QgaGFzaCBvZiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzW3RoaXMuZGVwdGhdWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZGVwdGggb2YgdGhlIHRyZWUsIHdoaWNoIGVxdWFscyB0aGUgbnVtYmVyIG9mIGxldmVscyAtIDEuXG4gICAgICogQHJldHVybnMgVGhlIGRlcHRoIG9mIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIGdldCBkZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsZWF2ZXMgb2YgdGhlIHRyZWUuIFRoZXkgY2FuIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGxldmVsIG9mIHRoZSB0cmVlIHVzaW5nIHtAbGluayBMZWFuSU1UI19ub2Rlc30uIFRoZSByZXR1cm5lZFxuICAgICAqIHZhbHVlIGlzIGEgY29weSBvZiB0aGUgYXJyYXkgYW5kIG5vdCB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIHRyZWUgbGVhdmVzLlxuICAgICAqL1xuICAgIGdldCBsZWF2ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXS5zbGljZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgdHJlZSwgd2hpY2ggdGhlIG51bWJlciBvZiBpdHMgbGVhdmVzLlxuICAgICAqIEl0J3MgdGhlIGxlbmd0aCBvZiB0aGUgZmlyc3QgbGV2ZWwncyBsaXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgbGVhdmVzIG9mIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCByZXR1cm5zIHRoZSBpbmRleCBvZiBhIGxlYWYuIElmIHRoZSBsZWFmIGRvZXMgbm90IGV4aXN0IGl0IHJldHVybnMgLTEuXG4gICAgICogQHBhcmFtIGxlYWYgQSBsZWFmIG9mIHRoZSB0cmVlLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgbGVhZi5cbiAgICAgKi9cbiAgICBpbmRleE9mKGxlYWYpIHtcbiAgICAgICAgcmVxdWlyZURlZmluZWQobGVhZiwgXCJsZWFmXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF0uaW5kZXhPZihsZWFmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQgcmV0dXJucyB0cnVlIGlmIHRoZSBsZWFmIGV4aXN0cywgYW5kIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBsZWFmIEEgbGVhZiBvZiB0aGUgdHJlZS5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0cmVlIGhhcyB0aGUgbGVhZiwgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBoYXMobGVhZikge1xuICAgICAgICByZXF1aXJlRGVmaW5lZChsZWFmLCBcImxlYWZcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXS5pbmNsdWRlcyhsZWFmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxlYXZlcyBhcmUgaW5zZXJ0ZWQgaW5jcmVtZW50YWxseS4gSWYgJ2knIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdFxuICAgICAqIGxlYWYsIHRoZSBuZXcgb25lIHdpbGwgYmUgaW5zZXJ0ZWQgYXQgcG9zaXRpb24gJ2kgKyAxJy4gRXZlcnkgdGltZSBhXG4gICAgICogbmV3IGxlYWYgaXMgaW5zZXJ0ZWQsIHRoZSBub2RlcyB0aGF0IHNlcGFyYXRlIHRoZSBuZXcgbGVhZiBmcm9tIHRoZSByb290XG4gICAgICogb2YgdGhlIHRyZWUgYXJlIGNyZWF0ZWQgb3IgdXBkYXRlZCBpZiB0aGV5IGFscmVhZHkgZXhpc3QsIGZyb20gYm90dG9tIHRvIHRvcC5cbiAgICAgKiBXaGVuIGEgbm9kZSBoYXMgb25seSBvbmUgY2hpbGQgKHRoZSBsZWZ0IG9uZSksIGl0cyB2YWx1ZSB0YWtlcyBvbiB0aGUgdmFsdWVcbiAgICAgKiBvZiB0aGUgY2hpbGQuIE90aGVyd2lzZSwgdGhlIGhhc2ggb2YgdGhlIGNoaWxkcmVuIGlzIGNhbGN1bGF0ZWQuXG4gICAgICogQHBhcmFtIGxlYWYgVGhlIG5ldyBsZWFmIHRvIGJlIGluc2VydGVkIGluIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIGluc2VydChsZWFmKSB7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKGxlYWYsIFwibGVhZlwiKTtcbiAgICAgICAgLy8gSWYgdGhlIG5leHQgZGVwdGggaXMgZ3JlYXRlciwgYSBuZXcgdHJlZSBsZXZlbCB3aWxsIGJlIGFkZGVkLlxuICAgICAgICBpZiAodGhpcy5kZXB0aCA8IE1hdGguY2VpbChNYXRoLmxvZzIodGhpcy5zaXplICsgMSkpKSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgYW4gYXJyYXkgaXMgbGlrZSBhZGRpbmcgYSBuZXcgbGV2ZWwuXG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IGxlYWY7XG4gICAgICAgIC8vIFRoZSBpbmRleCBvZiB0aGUgbmV3IGxlYWYgZXF1YWxzIHRoZSBudW1iZXIgb2YgbGVhdmVzIGluIHRoZSB0cmVlLlxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnNpemU7XG4gICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCB0aGlzLmRlcHRoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1tsZXZlbF1baW5kZXhdID0gbm9kZTtcbiAgICAgICAgICAgIC8vIEJpdHdpc2UgQU5ELCAwIC0+IGxlZnQgb3IgMSAtPiByaWdodC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIGlzIGEgcmlnaHQgbm9kZSB0aGUgcGFyZW50IG5vZGUgd2lsbCBiZSB0aGUgaGFzaFxuICAgICAgICAgICAgLy8gb2YgdGhlIGNoaWxkIG5vZGVzLiBPdGhlcndpc2UsIHBhcmVudCB3aWxsIGVxdWFsIGxlZnQgY2hpbGQgbm9kZS5cbiAgICAgICAgICAgIGlmIChpbmRleCAmIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5fbm9kZXNbbGV2ZWxdW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuX2hhc2goc2libGluZywgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSaWdodCBzaGlmdCwgaXQgZGl2aWRlcyBhIG51bWJlciBieSAyIGFuZCBkaXNjYXJkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgICAgICAgaW5kZXggPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIG5ldyByb290LlxuICAgICAgICB0aGlzLl9ub2Rlc1t0aGlzLmRlcHRoXSA9IFtub2RlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBpbnNlcnQgTiBsZWF2ZXMgYWxsIGF0IG9uY2UuXG4gICAgICogSXQgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiB1c2luZyB0aGUge0BsaW5rIExlYW5JTVQjaW5zZXJ0fSBtZXRob2QgTiB0aW1lcyBiZWNhdXNlIGl0XG4gICAgICogc2lnbmlmaWNhbnRseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgY2FzZXMgd2hlcmUgYSBub2RlIGhhcyBvbmx5IG9uZVxuICAgICAqIGNoaWxkLCB3aGljaCBpcyBhIGNvbW1vbiBvY2N1cnJlbmNlIGluIGdyYWR1YWwgaW5zZXJ0aW9uLlxuICAgICAqIEBwYXJhbSBsZWF2ZXMgVGhlIGxpc3Qgb2YgbGVhdmVzIHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIGluc2VydE1hbnkobGVhdmVzKSB7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKGxlYXZlcywgXCJsZWF2ZXNcIik7XG4gICAgICAgIHJlcXVpcmVBcnJheShsZWF2ZXMsIFwibGVhdmVzXCIpO1xuICAgICAgICBpZiAobGVhdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgYXJlIG5vIGxlYXZlcyB0byBhZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSB0aGlzLnNpemUgPj4gMTtcbiAgICAgICAgdGhpcy5fbm9kZXNbMF0ucHVzaCguLi5sZWF2ZXMpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgdHJlZSBsZXZlbHMgd2lsbCBuZWVkIHRvIGJlIGFkZGVkXG4gICAgICAgIC8vIHVzaW5nIHRoZSBudW1iZXIgb2YgbGVhdmVzLlxuICAgICAgICBjb25zdCBudW1iZXJPZk5ld0xldmVscyA9IE1hdGguY2VpbChNYXRoLmxvZzIodGhpcy5zaXplKSkgLSB0aGlzLmRlcHRoO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyBsZXZlbHMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZOZXdMZXZlbHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIG5vZGVzIG9mIHRoZSBuZXh0IGxldmVsLlxuICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZOb2RlcyA9IE1hdGguY2VpbCh0aGlzLl9ub2Rlc1tsZXZlbF0ubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgbnVtYmVyT2ZOb2RlczsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IHRoaXMuX25vZGVzW2xldmVsXVtpbmRleCAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0Tm9kZSA9IHRoaXMuX25vZGVzW2xldmVsXVtpbmRleCAqIDJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSByaWdodE5vZGUgPyB0aGlzLl9oYXNoKGxlZnROb2RlLCByaWdodE5vZGUpIDogbGVmdE5vZGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZXNbbGV2ZWwgKyAxXVtpbmRleF0gPSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRJbmRleCA+Pj0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCB1cGRhdGVzIGEgbGVhZiBpbiB0aGUgdHJlZS4gSXQncyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIHtAbGluayBMZWFuSU1UI2luc2VydH0gZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbGVhZiB0byBiZSB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSBuZXdMZWFmIFRoZSBuZXcgbGVhZiB0byBiZSBpbnNlcnRlZC5cbiAgICAgKi9cbiAgICB1cGRhdGUoaW5kZXgsIG5ld0xlYWYpIHtcbiAgICAgICAgcmVxdWlyZURlZmluZWQoaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKG5ld0xlYWYsIFwibmV3TGVhZlwiKTtcbiAgICAgICAgcmVxdWlyZU51bWJlcihpbmRleCwgXCJpbmRleFwiKTtcbiAgICAgICAgbGV0IG5vZGUgPSBuZXdMZWFmO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGhpcy5kZXB0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbbGV2ZWxdW2luZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBpZiAoaW5kZXggJiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IHRoaXMuX25vZGVzW2xldmVsXVtpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLl9oYXNoKHNpYmxpbmcsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHRoZXJlIGNvdWxkIHN0aWxsIGJlIGEgcmlnaHQgbm9kZVxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIHBhdGggbWlnaHQgbm90IGJlIHRoZSByaWdodG1vc3Qgb25lXG4gICAgICAgICAgICAgICAgLy8gKGxpa2UgdGhlICdpbnNlcnQnIGZ1bmN0aW9uKS5cbiAgICAgICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5fbm9kZXNbbGV2ZWxdW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuX2hhc2gobm9kZSwgc2libGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXNbdGhpcy5kZXB0aF0gPSBbbm9kZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgbSBsZWF2ZXMgYWxsIGF0IG9uY2UuXG4gICAgICogSXQgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiB1c2luZyB0aGUge0BsaW5rIExlYW5JTVQjdXBkYXRlfSBtZXRob2QgbSB0aW1lcyBiZWNhdXNlIGl0XG4gICAgICogcHJldmVudHMgdXBkYXRpbmcgbWlkZGxlIG5vZGVzIHNldmVyYWwgdGltZXMuIFRoaXMgd291bGQgaGFwcGVuIHdoZW4gdXBkYXRpbmcgbGVhdmVzXG4gICAgICogd2l0aCBjb21tb24gYW5jZXN0b3JzLiBUaGUgbmFpdmUgYXBwcm9hY2ggb2YgY2FsbGluZyAndXBkYXRlJyBtIHRpbWVzIGhhcyBjb21wbGV4aXR5XG4gICAgICogTyhtKmxvZyhuKSkgKHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiBsZWF2ZXMgb2YgdGhlIHRyZWUpLCB3aGljaCBlbmRzIHVwIGluXG4gICAgICogTyhuKmxvZyhuKSkgd2hlbiBtIH4gbi4gV2l0aCB0aGlzIG5ldyBhcHByb2FjaCwgdGhpcyBlbmRzIHVwIGJlaW5nIE8obikgYmVjYXVzZSBldmVyeVxuICAgICAqIG5vZGUgaXMgdXBkYXRlZCBhdCBtb3N0IG9uY2UgYW5kIHRoZXJlIGFyZSBhcm91bmQgMipuIG5vZGVzIGluIHRoZSB0cmVlLlxuICAgICAqIEBwYXJhbSBpbmRpY2VzIFRoZSBsaXN0IG9mIGluZGljZXMgb2YgdGhlIHJlc3BlY3RpdmUgbGVhdmVzLlxuICAgICAqIEBwYXJhbSBsZWF2ZXMgVGhlIGxpc3Qgb2YgbGVhdmVzIHRvIGJlIHVwZGF0ZWQuXG4gICAgICovXG4gICAgdXBkYXRlTWFueShpbmRpY2VzLCBsZWF2ZXMpIHtcbiAgICAgICAgcmVxdWlyZURlZmluZWQobGVhdmVzLCBcImxlYXZlc1wiKTtcbiAgICAgICAgcmVxdWlyZURlZmluZWQoaW5kaWNlcywgXCJpbmRpY2VzXCIpO1xuICAgICAgICByZXF1aXJlQXJyYXkobGVhdmVzLCBcImxlYXZlc1wiKTtcbiAgICAgICAgcmVxdWlyZUFycmF5KGluZGljZXMsIFwiaW5kaWNlc1wiKTtcbiAgICAgICAgaWYgKGxlYXZlcy5sZW5ndGggIT09IGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIGluZGljZXMgYW5kIGxlYXZlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHdpbGwga2VlcCB0cmFjayBvZiB0aGUgb3V0ZGF0ZWQgbm9kZXMgb2YgZWFjaCBsZXZlbC5cbiAgICAgICAgbGV0IG1vZGlmaWVkSW5kaWNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICByZXF1aXJlTnVtYmVyKGluZGljZXNbaV0sIGBpbmRleCAke2l9YCk7XG4gICAgICAgICAgICBpZiAoaW5kaWNlc1tpXSA8IDAgfHwgaW5kaWNlc1tpXSA+PSB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluZGV4ICR7aX0gaXMgb3V0IG9mIHJhbmdlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kaWZpZWRJbmRpY2VzLmhhcyhpbmRpY2VzW2ldKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGVhZiAke2luZGljZXNbaV19IGlzIHJlcGVhdGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RpZmllZEluZGljZXMuYWRkKGluZGljZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGlmaWVkSW5kaWNlcy5jbGVhcigpO1xuICAgICAgICAvLyBGaXJzdCwgbW9kaWZ5IHRoZSBmaXJzdCBsZXZlbCwgd2hpY2ggY29uc2lzdHMgb25seSBvZiByYXcsIHVuLWhhc2hlZCB2YWx1ZXNcbiAgICAgICAgZm9yIChsZXQgbGVhZiA9IDA7IGxlYWYgPCBpbmRpY2VzLmxlbmd0aDsgbGVhZiArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1swXVtpbmRpY2VzW2xlYWZdXSA9IGxlYXZlc1tsZWFmXTtcbiAgICAgICAgICAgIG1vZGlmaWVkSW5kaWNlcy5hZGQoaW5kaWNlc1tsZWFmXSA+PiAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgdXBkYXRlIGVhY2ggbm9kZSBvZiB0aGUgY29ycmVzcG9uZGluZyBsZXZlbHNcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAxOyBsZXZlbCA8PSB0aGlzLmRlcHRoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdNb2RpZmllZEluZGljZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgbW9kaWZpZWRJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdENoaWxkID0gdGhpcy5fbm9kZXNbbGV2ZWwgLSAxXVsyICogaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Q2hpbGQgPSB0aGlzLl9ub2Rlc1tsZXZlbCAtIDFdWzIgKiBpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vZGVzW2xldmVsXVtpbmRleF0gPSByaWdodENoaWxkID8gdGhpcy5faGFzaChsZWZ0Q2hpbGQsIHJpZ2h0Q2hpbGQpIDogbGVmdENoaWxkO1xuICAgICAgICAgICAgICAgIG5ld01vZGlmaWVkSW5kaWNlcy5wdXNoKGluZGV4ID4+IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kaWZpZWRJbmRpY2VzID0gbmV3IFNldChuZXdNb2RpZmllZEluZGljZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0IGdlbmVyYXRlcyBhIHtAbGluayBMZWFuSU1UTWVya2xlUHJvb2Z9IGZvciBhIGxlYWYgb2YgdGhlIHRyZWUuXG4gICAgICogVGhhdCBwcm9vZiBjYW4gYmUgdmVyaWZpZWQgYnkgdGhpcyB0cmVlIHVzaW5nIHRoZSBzYW1lIGhhc2ggZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbGVhZiBmb3Igd2hpY2ggYSBNZXJrbGUgcHJvb2Ygd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIE1lcmtsZSBwcm9vZiBvZiB0aGUgbGVhZi5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZVByb29mKGluZGV4KSB7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKGluZGV4LCBcImluZGV4XCIpO1xuICAgICAgICByZXF1aXJlTnVtYmVyKGluZGV4LCBcImluZGV4XCIpO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbGVhZiBhdCBpbmRleCAnJHtpbmRleH0nIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgdHJlZWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmxlYXZlc1tpbmRleF07XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgICAgIGNvbnN0IHBhdGggPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUmlnaHROb2RlID0gaW5kZXggJiAxO1xuICAgICAgICAgICAgY29uc3Qgc2libGluZ0luZGV4ID0gaXNSaWdodE5vZGUgPyBpbmRleCAtIDEgOiBpbmRleCArIDE7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5fbm9kZXNbbGV2ZWxdW3NpYmxpbmdJbmRleF07XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2libGluZyBub2RlIGRvZXMgbm90IGV4aXN0LCBpdCBtZWFucyB0aGF0IHRoZSBub2RlIGF0XG4gICAgICAgICAgICAvLyB0aGlzIGxldmVsIGhhcyB0aGUgc2FtZSB2YWx1ZSBhcyBpdHMgY2hpbGQuIFRoZXJlZm9yZSwgdGhlcmVcbiAgICAgICAgICAgIC8vIGlzIG5vIG5lZWQgdG8gaW5jbHVkZSBpdCBpbiB0aGUgcHJvb2Ygc2luY2UgdGhlcmUgaXMgbm8gaGFzaCB0byBjYWxjdWxhdGUuXG4gICAgICAgICAgICBpZiAoc2libGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKGlzUmlnaHROb2RlKTtcbiAgICAgICAgICAgICAgICBzaWJsaW5ncy5wdXNoKHNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGluZGV4IG1pZ2h0IGJlIGRpZmZlcmVudCBmcm9tIHRoZSBvcmlnaW5hbCBpbmRleCBvZiB0aGUgbGVhZiwgc2luY2VcbiAgICAgICAgLy8gaW4gc29tZSBjYXNlcyBzb21lIHNpYmxpbmdzIGFyZSBub3QgaW5jbHVkZWQgKGFzIGV4cGxhaW5lZCBhYm92ZSkuXG4gICAgICAgIHJldHVybiB7IHJvb3Q6IHRoaXMucm9vdCwgbGVhZiwgaW5kZXg6IE51bWJlci5wYXJzZUludChwYXRoLnJldmVyc2UoKS5qb2luKFwiXCIpLCAyKSwgc2libGluZ3MgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQgdmVyaWZpZXMgYSB7QGxpbmsgTGVhbklNVE1lcmtsZVByb29mfSB0byBjb25maXJtIHRoYXQgYSBsZWFmIGluZGVlZFxuICAgICAqIGJlbG9uZ3MgdG8gYSB0cmVlLiAgRG9lcyBub3QgdmVyaWZ5IHRoYXQgdGhlIG5vZGUgYmVsb25ncyB0byB0aGlzXG4gICAgICogdHJlZSBpbiBwYXJ0aWN1bGFyLiAgRXF1aXZhbGVudCB0b1xuICAgICAqIGBMZWFuSU1ULnZlcmlmeVByb29mKHByb29mLCB0aGlzLl9oYXNoKWAuXG4gICAgICogQHBhcmFtIHByb29mIFRoZSBNZXJrbGUgdHJlZSBwcm9vZi5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBsZWFmIGlzIHBhcnQgb2YgdGhlIHRyZWUsIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmVyaWZ5UHJvb2YocHJvb2YpIHtcbiAgICAgICAgcmV0dXJuIExlYW5JTVQudmVyaWZ5UHJvb2YocHJvb2YsIHRoaXMuX2hhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCB2ZXJpZmllcyBhIHtAbGluayBMZWFuSU1UTWVya2xlUHJvb2Z9IHRvIGNvbmZpcm0gdGhhdCBhIGxlYWYgaW5kZWVkXG4gICAgICogYmVsb25ncyB0byBhIHRyZWUuXG4gICAgICogQHBhcmFtIHByb29mIFRoZSBNZXJrbGUgdHJlZSBwcm9vZi5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBsZWFmIGlzIHBhcnQgb2YgdGhlIHRyZWUsIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhdGljIHZlcmlmeVByb29mKHByb29mLCBoYXNoKSB7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKHByb29mLCBcInByb29mXCIpO1xuICAgICAgICBjb25zdCB7IHJvb3QsIGxlYWYsIHNpYmxpbmdzLCBpbmRleCB9ID0gcHJvb2Y7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKHByb29mLnJvb3QsIFwicHJvb2Yucm9vdFwiKTtcbiAgICAgICAgcmVxdWlyZURlZmluZWQocHJvb2YubGVhZiwgXCJwcm9vZi5sZWFmXCIpO1xuICAgICAgICByZXF1aXJlRGVmaW5lZChwcm9vZi5zaWJsaW5ncywgXCJwcm9vZi5zaWJsaW5nc1wiKTtcbiAgICAgICAgcmVxdWlyZURlZmluZWQocHJvb2YuaW5kZXgsIFwicHJvb2YuaW5kZXhcIik7XG4gICAgICAgIHJlcXVpcmVBcnJheShwcm9vZi5zaWJsaW5ncywgXCJwcm9vZi5zaWJsaW5nc1wiKTtcbiAgICAgICAgcmVxdWlyZU51bWJlcihwcm9vZi5pbmRleCwgXCJwcm9vZi5pbmRleFwiKTtcbiAgICAgICAgbGV0IG5vZGUgPSBsZWFmO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpYmxpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoKGluZGV4ID4+IGkpICYgMSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBoYXNoKHNpYmxpbmdzW2ldLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBoYXNoKG5vZGUsIHNpYmxpbmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdCA9PT0gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQgZW5hYmxlcyB0aGUgY29udmVyc2lvbiBvZiB0aGUgZnVsbCB0cmVlIHN0cnVjdHVyZSBpbnRvIGEgSlNPTiBzdHJpbmcsXG4gICAgICogZmFjaWxpdGF0aW5nIGZ1dHVyZSBpbXBvcnRzIG9mIHRoZSB0cmVlLiBUaGlzIGFwcHJvYWNoIGlzIGJlbmVmaWNpYWwgZm9yXG4gICAgICogbGFyZ2UgdHJlZXMsIGFzIGl0IHNhdmVzIHRpbWUgYnkgc3RvcmluZyBoYXNoZXMgaW5zdGVhZCBvZiByZWNvbXB1dGluZyB0aGVtXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZ2lmaWVkIEpTT04gb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZXhwb3J0KCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5fbm9kZXMsIChfLCB2KSA9PiAodHlwZW9mIHYgPT09IFwiYmlnaW50XCIgPyB2LnRvU3RyaW5nKCkgOiB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0IGltcG9ydHMgYW4gZW50aXJlIHRyZWUgYnkgaW5pdGlhbGl6aW5nIHRoZSBub2RlcyB3aXRob3V0IGNhbGN1bGF0aW5nXG4gICAgICogYW55IGhhc2hlcy4gTm90ZSB0aGF0IGl0IGlzIGNydWNpYWwgdG8gZW5zdXJlIHRoZSBpbnRlZ3JpdHkgb2YgdGhlIHRyZWVcbiAgICAgKiBiZWZvcmUgb3IgYWZ0ZXIgaW1wb3J0aW5nIGl0LiBJZiB0aGUgbWFwIGZ1bmN0aW9uIGlzIG5vdCBkZWZpbmVkLCBub2RlXG4gICAgICogdmFsdWVzIHdpbGwgYmUgY29udmVydGVkIHRvIGJpZ2ludHMgYnkgZGVmYXVsdC5cbiAgICAgKiBAcGFyYW0gaGFzaCBUaGUgaGFzaCBmdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBub2Rlcy5cbiAgICAgKiBAcGFyYW0gbm9kZXMgVGhlIHN0cmluZ2lmaWVkIEpTT04gb2YgdGhlIHRyZWUuXG4gICAgICogQHBhcmFtIG1hcCBBIGZ1bmN0aW9uIHRvIG1hcCBlYWNoIG5vZGUgb2YgdGhlIHRyZWUgYW5kIGNvbnZlcnQgdGhlaXIgdHlwZXMuXG4gICAgICogQHJldHVybnMgQSBMZWFuSU1UIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbXBvcnQoaGFzaCwgbm9kZXMsIG1hcCkge1xuICAgICAgICByZXF1aXJlRGVmaW5lZChoYXNoLCBcImhhc2hcIik7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKG5vZGVzLCBcIm5vZGVzXCIpO1xuICAgICAgICByZXF1aXJlRnVuY3Rpb24oaGFzaCwgXCJoYXNoXCIpO1xuICAgICAgICByZXF1aXJlU3RyaW5nKG5vZGVzLCBcIm5vZGVzXCIpO1xuICAgICAgICBpZiAobWFwKSB7XG4gICAgICAgICAgICByZXF1aXJlRGVmaW5lZChtYXAsIFwibWFwXCIpO1xuICAgICAgICAgICAgcmVxdWlyZUZ1bmN0aW9uKG1hcCwgXCJtYXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJlZSA9IG5ldyBMZWFuSU1UKGhhc2gpO1xuICAgICAgICB0cmVlLl9ub2RlcyA9IEpTT04ucGFyc2Uobm9kZXMsIChfLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXAgPyBtYXAodmFsdWUpIDogQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTGVhbklNVCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@openpassport/zk-kit-lean-imt/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@openpassport/zk-kit-smt/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@openpassport/zk-kit-smt/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SMT: () => (/* binding */ SMT),\n/* harmony export */   checkHex: () => (/* binding */ checkHex),\n/* harmony export */   getFirstCommonElements: () => (/* binding */ getFirstCommonElements),\n/* harmony export */   getIndexOfLastNonZeroElement: () => (/* binding */ getIndexOfLastNonZeroElement),\n/* harmony export */   hexToBin: () => (/* binding */ hexToBin),\n/* harmony export */   keyToPath: () => (/* binding */ keyToPath)\n/* harmony export */ });\n/**\n * @module @openpassport/zk-kit-smt\n * @version 0.0.1\n * @file Sparse Merkle tree implementation in TypeScript.\n * @copyright Cedoor 2024\n * @license MIT\n * @see [Github]{@link https://www.openpassport.app/}\n*/\n/**\n * Converts a hexadecimal number to a binary number.\n * @param n A hexadecimal number.\n * @returns The relative binary number.\n */\nfunction hexToBin(n) {\n    let bin = Number(`0x${n[0]}`).toString(2);\n    for (let i = 1; i < n.length; i += 1) {\n        bin += Number(`0x${n[i]}`).toString(2).padStart(4, \"0\");\n    }\n    return bin;\n}\n/**\n * Returns the binary representation of a key. For each key it is possible\n * to obtain an array of 256 padded bits.\n * @param key The key of a tree entry.\n * @returns The relative array of bits.\n */\nfunction keyToPath(key) {\n    const bits = typeof key === \"bigint\" ? key.toString(2) : hexToBin(key);\n    return bits.padStart(256, \"0\").split(\"\").reverse().map(Number);\n}\n/**\n * Returns the index of the last non-zero element of an array.\n * If there are only zero elements the function returns -1.\n * @param array An array of hexadecimal or big numbers.\n * @returns The index of the last non-zero element.\n */\nfunction getIndexOfLastNonZeroElement(array) {\n    for (let i = array.length - 1; i >= 0; i -= 1) {\n        if (Number(`0x${array[i]}`) !== 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Returns the first common elements of two arrays.\n * @param array1 The first array.\n * @param array2 The second array.\n * @returns The array of the first common elements.\n */\nfunction getFirstCommonElements(array1, array2) {\n    const minArray = array1.length < array2.length ? array1 : array2;\n    for (let i = 0; i < minArray.length; i += 1) {\n        if (array1[i] !== array2[i]) {\n            return minArray.slice(0, i);\n        }\n    }\n    return minArray.slice();\n}\n/**\n * Checks if a number is a hexadecimal number.\n * @param n A hexadecimal number.\n * @returns True if the number is a hexadecimal, false otherwise.\n */\nfunction checkHex(n) {\n    return typeof n === \"string\" && /^[0-9A-Fa-f]{1,64}$/.test(n);\n}\n\n/**\n * SparseMerkleTree class provides all the functions to create a sparse Merkle tree\n * and to take advantage of its features: {@linkcode SMT.add}, {@linkcode SMT.get},\n * {@linkcode SMT.update}, {@linkcode SMT.delete}, {@linkcode SMT.createProof},\n * {@linkcode SMT.verifyProof}.\n * To better understand the code below it may be useful to describe the terminology used:\n * * **nodes**: every node in the tree is the hash of the two child nodes (`H(x, y)`);\n * * **root node**: the root node is the top hash and since it represents the whole data\n * structure it can be used to certify its integrity;\n * * **leaf nodes**: every leaf node is the hash of a key/value pair and an additional\n * value to mark the node as leaf node (`H(x, y, 1)`);\n * * **entry**: a tree entry is a key/value pair used to create the leaf nodes;\n * * **zero nodes**: a zero node is an hash of zeros and in this implementation `H(0,0) = 0`;\n * * **siblings**: the children of a parent node are siblings;\n * * **path**: every entry key is a number < 2^256 that can be converted in a binary number,\n * and this binary number is the path used to place the entry in the tree (1 or 0 define the\n * child node to choose);\n * * **matching node**: when an entry is not found and the path leads to another existing entry,\n * this entry is a matching entry and it has some of the first bits in common with the entry not found;\n * * **depth**: the depth of a node is the length of the path to its root.\n */\nclass SMT {\n    /**\n     * Initializes the SparseMerkleTree attributes.\n     * @param hash Hash function used to hash the child nodes.\n     * @param bigNumbers BigInt type enabling.\n     */\n    constructor(hash, bigNumbers = false) {\n        if (bigNumbers) {\n            /* istanbul ignore next */\n            if (typeof BigInt !== \"function\") {\n                throw new Error(\"Big numbers are not supported\");\n            }\n            if (typeof hash([BigInt(1), BigInt(1)]) !== \"bigint\") {\n                throw new Error(\"The hash function must return a big number\");\n            }\n        }\n        else if (!checkHex(hash([\"1\", \"1\"]))) {\n            throw new Error(\"The hash function must return a hexadecimal\");\n        }\n        this.hash = hash;\n        this.bigNumbers = bigNumbers;\n        this.zeroNode = bigNumbers ? BigInt(0) : \"0\";\n        this.entryMark = bigNumbers ? BigInt(1) : \"1\";\n        this.nodes = new Map();\n        this.root = this.zeroNode; // The root node is initially a zero node.\n    }\n    /**\n     * Gets a key and if the key exists in the tree the function returns the\n     * value, otherwise it returns 'undefined'.\n     * @param key A key of a tree entry.\n     * @returns A value of a tree entry or 'undefined'.\n     */\n    get(key) {\n        this.checkParameterType(key);\n        const { entry } = this.retrieveEntry(key);\n        return entry[1];\n    }\n    /**\n     * Adds a new entry in the tree. It retrieves a matching entry\n     * or a zero node with a top-down approach and then it updates all the\n     * hashes of the nodes in the path of the new entry with a bottom-up approach.\n     * @param key The key of the new entry.\n     * @param value The value of the new entry.\n     */\n    add(key, value) {\n        this.checkParameterType(key);\n        this.checkParameterType(value);\n        const { entry, matchingEntry, siblings } = this.retrieveEntry(key);\n        if (entry[1] !== undefined) {\n            throw new Error(`Key \"${key}\" already exists`);\n        }\n        const path = keyToPath(key);\n        // If there is a matching entry its node is saved, otherwise\n        // the node is a zero node. This node is used below as the first node\n        // (starting from the bottom of the tree) to obtain the new nodes\n        // up to the root.\n        const node = matchingEntry ? this.hash(matchingEntry) : this.zeroNode;\n        // If there are siblings it deletes all the nodes of the path.\n        // These nodes will be re-created below with the new hashes.\n        if (siblings.length > 0) {\n            this.deleteOldNodes(node, path, siblings);\n        }\n        // If there is a matching entry, further N zero siblings are added\n        // in the `siblings` array, followed by the matching node itself.\n        // N is the number of the first matching bits of the paths.\n        // This is helpful in the non-membership proof verification\n        // as explained in the function below.\n        if (matchingEntry) {\n            const matchingPath = keyToPath(matchingEntry[0]);\n            for (let i = siblings.length; matchingPath[i] === path[i]; i += 1) {\n                siblings.push(this.zeroNode);\n            }\n            siblings.push(node);\n        }\n        // Adds the new entry and re-creates the nodes of the path with the new hashes\n        // with a bottom-up approach. The `addNewNodes` function returns the last node\n        // added, which is the root node.\n        const newNode = this.hash([key, value, this.entryMark]);\n        this.nodes.set(newNode, [key, value, this.entryMark]);\n        this.root = this.addNewNodes(newNode, path, siblings);\n    }\n    /**\n     * Updates a value of an entry in the tree. Also in this case\n     * all the hashes of the nodes in the path of the entry are updated\n     * with a bottom-up approach.\n     * @param key The key of the entry.\n     * @param value The value of the entry.\n     */\n    update(key, value) {\n        this.checkParameterType(key);\n        this.checkParameterType(value);\n        const { entry, siblings } = this.retrieveEntry(key);\n        if (entry[1] === undefined) {\n            throw new Error(`Key \"${key}\" does not exist`);\n        }\n        const path = keyToPath(key);\n        // Deletes the old entry and all the nodes in its path.\n        const oldNode = this.hash(entry);\n        this.nodes.delete(oldNode);\n        this.deleteOldNodes(oldNode, path, siblings);\n        // Adds the new entry and re-creates the nodes of the path\n        // with the new hashes.\n        const newNode = this.hash([key, value, this.entryMark]);\n        this.nodes.set(newNode, [key, value, this.entryMark]);\n        this.root = this.addNewNodes(newNode, path, siblings);\n    }\n    /**\n     * Deletes an entry in the tree. Also in this case all the hashes of\n     * the nodes in the path of the entry are updated with a bottom-up approach.\n     * @param key The key of the entry.\n     */\n    delete(key) {\n        this.checkParameterType(key);\n        const { entry, siblings } = this.retrieveEntry(key);\n        if (entry[1] === undefined) {\n            throw new Error(`Key \"${key}\" does not exist`);\n        }\n        const path = keyToPath(key);\n        // Deletes the entry.\n        const node = this.hash(entry);\n        this.nodes.delete(node);\n        this.root = this.zeroNode;\n        // If there are siblings it deletes the nodes of the path and\n        // re-creates them with the new hashes.\n        if (siblings.length > 0) {\n            this.deleteOldNodes(node, path, siblings);\n            // If the last siblings is not a leaf node, it adds all the\n            // nodes of the path starting from a zero node, otherwise\n            // it removes the last non-zero siblings from the `siblings`\n            // array and it starts from it by skipping the last zero nodes.\n            if (!this.isLeaf(siblings[siblings.length - 1])) {\n                this.root = this.addNewNodes(this.zeroNode, path, siblings);\n            }\n            else {\n                const firstSibling = siblings.pop();\n                const i = getIndexOfLastNonZeroElement(siblings);\n                this.root = this.addNewNodes(firstSibling, path, siblings, i);\n            }\n        }\n    }\n    /**\n     * Creates a proof to prove the membership or the non-membership\n     * of a tree entry.\n     * @param key A key of an existing or a non-existing entry.\n     * @returns The membership or the non-membership proof.\n     */\n    createProof(key) {\n        this.checkParameterType(key);\n        const { entry, matchingEntry, siblings } = this.retrieveEntry(key);\n        // If the key exists the function returns a membership proof, otherwise it\n        // returns a non-membership proof with the matching entry.\n        return {\n            entry,\n            matchingEntry,\n            siblings,\n            root: this.root,\n            membership: !!entry[1]\n        };\n    }\n    /**\n     * Verifies a membership or a non-membership proof.\n     * @param merkleProof The proof to verify.\n     * @returns True if the proof is valid, false otherwise.\n     */\n    verifyProof(merkleProof) {\n        // If there is not a matching entry it simply obtains the root\n        // hash by using the siblings and the path of the key.\n        if (!merkleProof.matchingEntry) {\n            const path = keyToPath(merkleProof.entry[0]);\n            // If there is not an entry value the proof is a non-membership proof,\n            // and in this case, since there is not a matching entry, the node\n            // is a zero node. If there is an entry value the proof is a\n            // membership proof and the node is the hash of the entry.\n            const node = merkleProof.entry[1] !== undefined ? this.hash(merkleProof.entry) : this.zeroNode;\n            const root = this.calculateRoot(node, path, merkleProof.siblings);\n            // If the obtained root is equal to the proof root, then the proof is valid.\n            return root === merkleProof.root;\n        }\n        // If there is a matching entry the proof is definitely a non-membership\n        // proof. In this case it checks if the matching node belongs to the tree\n        // and then it checks if the number of the first matching bits of the keys\n        // is greater than or equal to the number of the siblings.\n        const matchingPath = keyToPath(merkleProof.matchingEntry[0]);\n        const node = this.hash(merkleProof.matchingEntry);\n        const root = this.calculateRoot(node, matchingPath, merkleProof.siblings);\n        if (root === merkleProof.root) {\n            const path = keyToPath(merkleProof.entry[0]);\n            // Returns the first common bits of the two keys: the\n            // non-member key and the matching key.\n            const firstMatchingBits = getFirstCommonElements(path, matchingPath);\n            // If the non-member key was a key of a tree entry, the depth of the\n            // matching node should be greater than the number of the first common\n            // bits of the keys. The depth of a node can be defined by the number\n            // of its siblings.\n            return merkleProof.siblings.length <= firstMatchingBits.length;\n        }\n        return false;\n    }\n    /**\n     * It enables the conversion of the full tree structure into a JSON string,\n     * facilitating future imports of the tree. This approach is beneficial for\n     * sharing across networks, as it saves time by storing root and the map of\n     * hashed nodes directly instead of recomputing them\n     * @returns The stringified JSON of the tree.\n     */\n    export() {\n        const obj = {};\n        obj.root = [this.root.toString()];\n        this.nodes.forEach((value, key) => {\n            obj[key.toString()] = value.map((v) => v.toString());\n        });\n        return JSON.stringify(obj, null, 2);\n    }\n    /**\n     * It imports an entire tree by initializing the nodes and root without calculating\n     * any hashes. Note that it is crucial to ensure the integrity of the tree\n     * before or after importing it.\n     * The tree must be empty before importing.\n     * @param nodes The stringified JSON of the tree.\n     */\n    import(json) {\n        const obj = JSON.parse(json);\n        const map = new Map();\n        for (const [key, value] of Object.entries(obj)) {\n            if (key === \"root\") {\n                this.root = this.bigNumbers ? BigInt(value[0]) : value[0];\n            }\n            else {\n                const Key = this.bigNumbers ? BigInt(key) : key;\n                if (this.bigNumbers) {\n                    const Children = value.map((v) => BigInt(v));\n                    map.set(Key, Children);\n                }\n                else {\n                    map.set(Key, value);\n                }\n            }\n        }\n        this.nodes = map;\n    }\n    /**\n     * Searches for an entry in the tree. If the key passed as parameter exists in\n     * the tree, the function returns the entry, otherwise it returns the entry\n     * with only the key, and when there is another existing entry\n     * in the same path it returns also this entry as 'matching entry'.\n     * In any case the function returns the siblings of the path.\n     * @param key The key of the entry to search for.\n     * @returns The entry response.\n     */\n    retrieveEntry(key) {\n        const path = keyToPath(key);\n        const siblings = [];\n        // Starts from the root and goes down into the tree until it finds\n        // the entry, a zero node or a matching entry.\n        for (let i = 0, node = this.root; node !== this.zeroNode; i += 1) {\n            const childNodes = this.nodes.get(node);\n            const direction = path[i];\n            // If the third position of the array is not empty the child nodes\n            // are an entry of the tree.\n            if (childNodes[2]) {\n                if (childNodes[0] === key) {\n                    // An entry with the same key was found and\n                    // it returns it with the siblings.\n                    return { entry: childNodes, siblings };\n                }\n                // The entry found does not have the same key. But the key of this\n                // particular entry matches the first 'i' bits of the key passed\n                // as parameter and it can be useful in several functions.\n                return { entry: [key], matchingEntry: childNodes, siblings };\n            }\n            // When it goes down into the tree and follows the path, in every step\n            // a node is chosen between the left and the right child nodes, and the\n            // opposite node is saved as siblings.\n            node = childNodes[direction];\n            siblings.push(childNodes[Number(!direction)]);\n        }\n        // The path led to a zero node.\n        return { entry: [key], siblings };\n    }\n    /**\n     * Calculates nodes with a bottom-up approach until it reaches the root node.\n     * @param node The node to start from.\n     * @param path The path of the key.\n     * @param siblings The siblings of the path.\n     * @returns The root node.\n     */\n    calculateRoot(node, path, siblings) {\n        for (let i = siblings.length - 1; i >= 0; i -= 1) {\n            const childNodes = path[i] ? [siblings[i], node] : [node, siblings[i]];\n            node = this.hash(childNodes);\n        }\n        return node;\n    }\n    /**\n     * Adds new nodes in the tree with a bottom-up approach until it reaches the root node.\n     * @param node The node to start from.\n     * @param path The path of the key.\n     * @param siblings The siblings of the path.\n     * @param i The index to start from.\n     * @returns The root node.\n     */\n    addNewNodes(node, path, siblings, i = siblings.length - 1) {\n        for (; i >= 0; i -= 1) {\n            const childNodes = path[i] ? [siblings[i], node] : [node, siblings[i]];\n            node = this.hash(childNodes);\n            this.nodes.set(node, childNodes);\n        }\n        return node;\n    }\n    /**\n     * Deletes nodes in the tree with a bottom-up approach until it reaches the root node.\n     * @param node The node to start from.\n     * @param path The path of the key.\n     * @param siblings The siblings of the path.\n     */\n    deleteOldNodes(node, path, siblings) {\n        for (let i = siblings.length - 1; i >= 0; i -= 1) {\n            const childNodes = path[i] ? [siblings[i], node] : [node, siblings[i]];\n            node = this.hash(childNodes);\n            this.nodes.delete(node);\n        }\n    }\n    /**\n     * Checks if a node is a leaf node.\n     * @param node A node of the tree.\n     * @returns True if the node is a leaf, false otherwise.\n     */\n    isLeaf(node) {\n        const childNodes = this.nodes.get(node);\n        return !!(childNodes && childNodes[2]);\n    }\n    /**\n     * Checks the parameter type.\n     * @param parameter The parameter to check.\n     */\n    checkParameterType(parameter) {\n        if (this.bigNumbers && typeof parameter !== \"bigint\") {\n            throw new Error(`Parameter ${parameter} must be a big number`);\n        }\n        if (!this.bigNumbers && !checkHex(parameter)) {\n            throw new Error(`Parameter ${parameter} must be a hexadecimal`);\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9wZW5wYXNzcG9ydC96ay1raXQtc210L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0Isb0JBQW9CLGNBQWM7QUFDbEMsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGtCQUFrQixHQUFHLGtCQUFrQjtBQUNsRixJQUFJLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLDBCQUEwQjtBQUM5RSxJQUFJLDBCQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkJBQTZCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3QkFBd0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFb0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZWxmLXdvcmtzaG9wLy4vbm9kZV9tb2R1bGVzL0BvcGVucGFzc3BvcnQvemsta2l0LXNtdC9kaXN0L2luZGV4LmpzP2Y1YjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEBvcGVucGFzc3BvcnQvemsta2l0LXNtdFxuICogQHZlcnNpb24gMC4wLjFcbiAqIEBmaWxlIFNwYXJzZSBNZXJrbGUgdHJlZSBpbXBsZW1lbnRhdGlvbiBpbiBUeXBlU2NyaXB0LlxuICogQGNvcHlyaWdodCBDZWRvb3IgMjAyNFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAc2VlIFtHaXRodWJde0BsaW5rIGh0dHBzOi8vd3d3Lm9wZW5wYXNzcG9ydC5hcHAvfVxuKi9cbi8qKlxuICogQ29udmVydHMgYSBoZXhhZGVjaW1hbCBudW1iZXIgdG8gYSBiaW5hcnkgbnVtYmVyLlxuICogQHBhcmFtIG4gQSBoZXhhZGVjaW1hbCBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgcmVsYXRpdmUgYmluYXJ5IG51bWJlci5cbiAqL1xuZnVuY3Rpb24gaGV4VG9CaW4obikge1xuICAgIGxldCBiaW4gPSBOdW1iZXIoYDB4JHtuWzBdfWApLnRvU3RyaW5nKDIpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBiaW4gKz0gTnVtYmVyKGAweCR7bltpXX1gKS50b1N0cmluZygyKS5wYWRTdGFydCg0LCBcIjBcIik7XG4gICAgfVxuICAgIHJldHVybiBiaW47XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBhIGtleS4gRm9yIGVhY2gga2V5IGl0IGlzIHBvc3NpYmxlXG4gKiB0byBvYnRhaW4gYW4gYXJyYXkgb2YgMjU2IHBhZGRlZCBiaXRzLlxuICogQHBhcmFtIGtleSBUaGUga2V5IG9mIGEgdHJlZSBlbnRyeS5cbiAqIEByZXR1cm5zIFRoZSByZWxhdGl2ZSBhcnJheSBvZiBiaXRzLlxuICovXG5mdW5jdGlvbiBrZXlUb1BhdGgoa2V5KSB7XG4gICAgY29uc3QgYml0cyA9IHR5cGVvZiBrZXkgPT09IFwiYmlnaW50XCIgPyBrZXkudG9TdHJpbmcoMikgOiBoZXhUb0JpbihrZXkpO1xuICAgIHJldHVybiBiaXRzLnBhZFN0YXJ0KDI1NiwgXCIwXCIpLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5tYXAoTnVtYmVyKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXplcm8gZWxlbWVudCBvZiBhbiBhcnJheS5cbiAqIElmIHRoZXJlIGFyZSBvbmx5IHplcm8gZWxlbWVudHMgdGhlIGZ1bmN0aW9uIHJldHVybnMgLTEuXG4gKiBAcGFyYW0gYXJyYXkgQW4gYXJyYXkgb2YgaGV4YWRlY2ltYWwgb3IgYmlnIG51bWJlcnMuXG4gKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXplcm8gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5kZXhPZkxhc3ROb25aZXJvRWxlbWVudChhcnJheSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBpZiAoTnVtYmVyKGAweCR7YXJyYXlbaV19YCkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY29tbW9uIGVsZW1lbnRzIG9mIHR3byBhcnJheXMuXG4gKiBAcGFyYW0gYXJyYXkxIFRoZSBmaXJzdCBhcnJheS5cbiAqIEBwYXJhbSBhcnJheTIgVGhlIHNlY29uZCBhcnJheS5cbiAqIEByZXR1cm5zIFRoZSBhcnJheSBvZiB0aGUgZmlyc3QgY29tbW9uIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBnZXRGaXJzdENvbW1vbkVsZW1lbnRzKGFycmF5MSwgYXJyYXkyKSB7XG4gICAgY29uc3QgbWluQXJyYXkgPSBhcnJheTEubGVuZ3RoIDwgYXJyYXkyLmxlbmd0aCA/IGFycmF5MSA6IGFycmF5MjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbkFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChhcnJheTFbaV0gIT09IGFycmF5MltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbkFycmF5LnNsaWNlKDAsIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW5BcnJheS5zbGljZSgpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBudW1iZXIgaXMgYSBoZXhhZGVjaW1hbCBudW1iZXIuXG4gKiBAcGFyYW0gbiBBIGhleGFkZWNpbWFsIG51bWJlci5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG51bWJlciBpcyBhIGhleGFkZWNpbWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrSGV4KG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT09IFwic3RyaW5nXCIgJiYgL15bMC05QS1GYS1mXXsxLDY0fSQvLnRlc3Qobik7XG59XG5cbi8qKlxuICogU3BhcnNlTWVya2xlVHJlZSBjbGFzcyBwcm92aWRlcyBhbGwgdGhlIGZ1bmN0aW9ucyB0byBjcmVhdGUgYSBzcGFyc2UgTWVya2xlIHRyZWVcbiAqIGFuZCB0byB0YWtlIGFkdmFudGFnZSBvZiBpdHMgZmVhdHVyZXM6IHtAbGlua2NvZGUgU01ULmFkZH0sIHtAbGlua2NvZGUgU01ULmdldH0sXG4gKiB7QGxpbmtjb2RlIFNNVC51cGRhdGV9LCB7QGxpbmtjb2RlIFNNVC5kZWxldGV9LCB7QGxpbmtjb2RlIFNNVC5jcmVhdGVQcm9vZn0sXG4gKiB7QGxpbmtjb2RlIFNNVC52ZXJpZnlQcm9vZn0uXG4gKiBUbyBiZXR0ZXIgdW5kZXJzdGFuZCB0aGUgY29kZSBiZWxvdyBpdCBtYXkgYmUgdXNlZnVsIHRvIGRlc2NyaWJlIHRoZSB0ZXJtaW5vbG9neSB1c2VkOlxuICogKiAqKm5vZGVzKio6IGV2ZXJ5IG5vZGUgaW4gdGhlIHRyZWUgaXMgdGhlIGhhc2ggb2YgdGhlIHR3byBjaGlsZCBub2RlcyAoYEgoeCwgeSlgKTtcbiAqICogKipyb290IG5vZGUqKjogdGhlIHJvb3Qgbm9kZSBpcyB0aGUgdG9wIGhhc2ggYW5kIHNpbmNlIGl0IHJlcHJlc2VudHMgdGhlIHdob2xlIGRhdGFcbiAqIHN0cnVjdHVyZSBpdCBjYW4gYmUgdXNlZCB0byBjZXJ0aWZ5IGl0cyBpbnRlZ3JpdHk7XG4gKiAqICoqbGVhZiBub2RlcyoqOiBldmVyeSBsZWFmIG5vZGUgaXMgdGhlIGhhc2ggb2YgYSBrZXkvdmFsdWUgcGFpciBhbmQgYW4gYWRkaXRpb25hbFxuICogdmFsdWUgdG8gbWFyayB0aGUgbm9kZSBhcyBsZWFmIG5vZGUgKGBIKHgsIHksIDEpYCk7XG4gKiAqICoqZW50cnkqKjogYSB0cmVlIGVudHJ5IGlzIGEga2V5L3ZhbHVlIHBhaXIgdXNlZCB0byBjcmVhdGUgdGhlIGxlYWYgbm9kZXM7XG4gKiAqICoqemVybyBub2RlcyoqOiBhIHplcm8gbm9kZSBpcyBhbiBoYXNoIG9mIHplcm9zIGFuZCBpbiB0aGlzIGltcGxlbWVudGF0aW9uIGBIKDAsMCkgPSAwYDtcbiAqICogKipzaWJsaW5ncyoqOiB0aGUgY2hpbGRyZW4gb2YgYSBwYXJlbnQgbm9kZSBhcmUgc2libGluZ3M7XG4gKiAqICoqcGF0aCoqOiBldmVyeSBlbnRyeSBrZXkgaXMgYSBudW1iZXIgPCAyXjI1NiB0aGF0IGNhbiBiZSBjb252ZXJ0ZWQgaW4gYSBiaW5hcnkgbnVtYmVyLFxuICogYW5kIHRoaXMgYmluYXJ5IG51bWJlciBpcyB0aGUgcGF0aCB1c2VkIHRvIHBsYWNlIHRoZSBlbnRyeSBpbiB0aGUgdHJlZSAoMSBvciAwIGRlZmluZSB0aGVcbiAqIGNoaWxkIG5vZGUgdG8gY2hvb3NlKTtcbiAqICogKiptYXRjaGluZyBub2RlKio6IHdoZW4gYW4gZW50cnkgaXMgbm90IGZvdW5kIGFuZCB0aGUgcGF0aCBsZWFkcyB0byBhbm90aGVyIGV4aXN0aW5nIGVudHJ5LFxuICogdGhpcyBlbnRyeSBpcyBhIG1hdGNoaW5nIGVudHJ5IGFuZCBpdCBoYXMgc29tZSBvZiB0aGUgZmlyc3QgYml0cyBpbiBjb21tb24gd2l0aCB0aGUgZW50cnkgbm90IGZvdW5kO1xuICogKiAqKmRlcHRoKio6IHRoZSBkZXB0aCBvZiBhIG5vZGUgaXMgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCB0byBpdHMgcm9vdC5cbiAqL1xuY2xhc3MgU01UIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgU3BhcnNlTWVya2xlVHJlZSBhdHRyaWJ1dGVzLlxuICAgICAqIEBwYXJhbSBoYXNoIEhhc2ggZnVuY3Rpb24gdXNlZCB0byBoYXNoIHRoZSBjaGlsZCBub2Rlcy5cbiAgICAgKiBAcGFyYW0gYmlnTnVtYmVycyBCaWdJbnQgdHlwZSBlbmFibGluZy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBiaWdOdW1iZXJzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGJpZ051bWJlcnMpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIEJpZ0ludCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlnIG51bWJlcnMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhc2goW0JpZ0ludCgxKSwgQmlnSW50KDEpXSkgIT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgaGFzaCBmdW5jdGlvbiBtdXN0IHJldHVybiBhIGJpZyBudW1iZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoZWNrSGV4KGhhc2goW1wiMVwiLCBcIjFcIl0pKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGhhc2ggZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBoZXhhZGVjaW1hbFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICB0aGlzLmJpZ051bWJlcnMgPSBiaWdOdW1iZXJzO1xuICAgICAgICB0aGlzLnplcm9Ob2RlID0gYmlnTnVtYmVycyA/IEJpZ0ludCgwKSA6IFwiMFwiO1xuICAgICAgICB0aGlzLmVudHJ5TWFyayA9IGJpZ051bWJlcnMgPyBCaWdJbnQoMSkgOiBcIjFcIjtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy56ZXJvTm9kZTsgLy8gVGhlIHJvb3Qgbm9kZSBpcyBpbml0aWFsbHkgYSB6ZXJvIG5vZGUuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBrZXkgYW5kIGlmIHRoZSBrZXkgZXhpc3RzIGluIHRoZSB0cmVlIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICAgICAqIHZhbHVlLCBvdGhlcndpc2UgaXQgcmV0dXJucyAndW5kZWZpbmVkJy5cbiAgICAgKiBAcGFyYW0ga2V5IEEga2V5IG9mIGEgdHJlZSBlbnRyeS5cbiAgICAgKiBAcmV0dXJucyBBIHZhbHVlIG9mIGEgdHJlZSBlbnRyeSBvciAndW5kZWZpbmVkJy5cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHRoaXMuY2hlY2tQYXJhbWV0ZXJUeXBlKGtleSk7XG4gICAgICAgIGNvbnN0IHsgZW50cnkgfSA9IHRoaXMucmV0cmlldmVFbnRyeShrZXkpO1xuICAgICAgICByZXR1cm4gZW50cnlbMV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZW50cnkgaW4gdGhlIHRyZWUuIEl0IHJldHJpZXZlcyBhIG1hdGNoaW5nIGVudHJ5XG4gICAgICogb3IgYSB6ZXJvIG5vZGUgd2l0aCBhIHRvcC1kb3duIGFwcHJvYWNoIGFuZCB0aGVuIGl0IHVwZGF0ZXMgYWxsIHRoZVxuICAgICAqIGhhc2hlcyBvZiB0aGUgbm9kZXMgaW4gdGhlIHBhdGggb2YgdGhlIG5ldyBlbnRyeSB3aXRoIGEgYm90dG9tLXVwIGFwcHJvYWNoLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbmV3IGVudHJ5LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIG5ldyBlbnRyeS5cbiAgICAgKi9cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrUGFyYW1ldGVyVHlwZShrZXkpO1xuICAgICAgICB0aGlzLmNoZWNrUGFyYW1ldGVyVHlwZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHsgZW50cnksIG1hdGNoaW5nRW50cnksIHNpYmxpbmdzIH0gPSB0aGlzLnJldHJpZXZlRW50cnkoa2V5KTtcbiAgICAgICAgaWYgKGVudHJ5WzFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5IFwiJHtrZXl9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoID0ga2V5VG9QYXRoKGtleSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgZW50cnkgaXRzIG5vZGUgaXMgc2F2ZWQsIG90aGVyd2lzZVxuICAgICAgICAvLyB0aGUgbm9kZSBpcyBhIHplcm8gbm9kZS4gVGhpcyBub2RlIGlzIHVzZWQgYmVsb3cgYXMgdGhlIGZpcnN0IG5vZGVcbiAgICAgICAgLy8gKHN0YXJ0aW5nIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgdHJlZSkgdG8gb2J0YWluIHRoZSBuZXcgbm9kZXNcbiAgICAgICAgLy8gdXAgdG8gdGhlIHJvb3QuXG4gICAgICAgIGNvbnN0IG5vZGUgPSBtYXRjaGluZ0VudHJ5ID8gdGhpcy5oYXNoKG1hdGNoaW5nRW50cnkpIDogdGhpcy56ZXJvTm9kZTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHNpYmxpbmdzIGl0IGRlbGV0ZXMgYWxsIHRoZSBub2RlcyBvZiB0aGUgcGF0aC5cbiAgICAgICAgLy8gVGhlc2Ugbm9kZXMgd2lsbCBiZSByZS1jcmVhdGVkIGJlbG93IHdpdGggdGhlIG5ldyBoYXNoZXMuXG4gICAgICAgIGlmIChzaWJsaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZU9sZE5vZGVzKG5vZGUsIHBhdGgsIHNpYmxpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIG1hdGNoaW5nIGVudHJ5LCBmdXJ0aGVyIE4gemVybyBzaWJsaW5ncyBhcmUgYWRkZWRcbiAgICAgICAgLy8gaW4gdGhlIGBzaWJsaW5nc2AgYXJyYXksIGZvbGxvd2VkIGJ5IHRoZSBtYXRjaGluZyBub2RlIGl0c2VsZi5cbiAgICAgICAgLy8gTiBpcyB0aGUgbnVtYmVyIG9mIHRoZSBmaXJzdCBtYXRjaGluZyBiaXRzIG9mIHRoZSBwYXRocy5cbiAgICAgICAgLy8gVGhpcyBpcyBoZWxwZnVsIGluIHRoZSBub24tbWVtYmVyc2hpcCBwcm9vZiB2ZXJpZmljYXRpb25cbiAgICAgICAgLy8gYXMgZXhwbGFpbmVkIGluIHRoZSBmdW5jdGlvbiBiZWxvdy5cbiAgICAgICAgaWYgKG1hdGNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nUGF0aCA9IGtleVRvUGF0aChtYXRjaGluZ0VudHJ5WzBdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzaWJsaW5ncy5sZW5ndGg7IG1hdGNoaW5nUGF0aFtpXSA9PT0gcGF0aFtpXTsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgc2libGluZ3MucHVzaCh0aGlzLnplcm9Ob2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpYmxpbmdzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkcyB0aGUgbmV3IGVudHJ5IGFuZCByZS1jcmVhdGVzIHRoZSBub2RlcyBvZiB0aGUgcGF0aCB3aXRoIHRoZSBuZXcgaGFzaGVzXG4gICAgICAgIC8vIHdpdGggYSBib3R0b20tdXAgYXBwcm9hY2guIFRoZSBgYWRkTmV3Tm9kZXNgIGZ1bmN0aW9uIHJldHVybnMgdGhlIGxhc3Qgbm9kZVxuICAgICAgICAvLyBhZGRlZCwgd2hpY2ggaXMgdGhlIHJvb3Qgbm9kZS5cbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHRoaXMuaGFzaChba2V5LCB2YWx1ZSwgdGhpcy5lbnRyeU1hcmtdKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5zZXQobmV3Tm9kZSwgW2tleSwgdmFsdWUsIHRoaXMuZW50cnlNYXJrXSk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuYWRkTmV3Tm9kZXMobmV3Tm9kZSwgcGF0aCwgc2libGluZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgdmFsdWUgb2YgYW4gZW50cnkgaW4gdGhlIHRyZWUuIEFsc28gaW4gdGhpcyBjYXNlXG4gICAgICogYWxsIHRoZSBoYXNoZXMgb2YgdGhlIG5vZGVzIGluIHRoZSBwYXRoIG9mIHRoZSBlbnRyeSBhcmUgdXBkYXRlZFxuICAgICAqIHdpdGggYSBib3R0b20tdXAgYXBwcm9hY2guXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBlbnRyeS5cbiAgICAgKi9cbiAgICB1cGRhdGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrUGFyYW1ldGVyVHlwZShrZXkpO1xuICAgICAgICB0aGlzLmNoZWNrUGFyYW1ldGVyVHlwZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHsgZW50cnksIHNpYmxpbmdzIH0gPSB0aGlzLnJldHJpZXZlRW50cnkoa2V5KTtcbiAgICAgICAgaWYgKGVudHJ5WzFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5IFwiJHtrZXl9XCIgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoID0ga2V5VG9QYXRoKGtleSk7XG4gICAgICAgIC8vIERlbGV0ZXMgdGhlIG9sZCBlbnRyeSBhbmQgYWxsIHRoZSBub2RlcyBpbiBpdHMgcGF0aC5cbiAgICAgICAgY29uc3Qgb2xkTm9kZSA9IHRoaXMuaGFzaChlbnRyeSk7XG4gICAgICAgIHRoaXMubm9kZXMuZGVsZXRlKG9sZE5vZGUpO1xuICAgICAgICB0aGlzLmRlbGV0ZU9sZE5vZGVzKG9sZE5vZGUsIHBhdGgsIHNpYmxpbmdzKTtcbiAgICAgICAgLy8gQWRkcyB0aGUgbmV3IGVudHJ5IGFuZCByZS1jcmVhdGVzIHRoZSBub2RlcyBvZiB0aGUgcGF0aFxuICAgICAgICAvLyB3aXRoIHRoZSBuZXcgaGFzaGVzLlxuICAgICAgICBjb25zdCBuZXdOb2RlID0gdGhpcy5oYXNoKFtrZXksIHZhbHVlLCB0aGlzLmVudHJ5TWFya10pO1xuICAgICAgICB0aGlzLm5vZGVzLnNldChuZXdOb2RlLCBba2V5LCB2YWx1ZSwgdGhpcy5lbnRyeU1hcmtdKTtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5hZGROZXdOb2RlcyhuZXdOb2RlLCBwYXRoLCBzaWJsaW5ncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gZW50cnkgaW4gdGhlIHRyZWUuIEFsc28gaW4gdGhpcyBjYXNlIGFsbCB0aGUgaGFzaGVzIG9mXG4gICAgICogdGhlIG5vZGVzIGluIHRoZSBwYXRoIG9mIHRoZSBlbnRyeSBhcmUgdXBkYXRlZCB3aXRoIGEgYm90dG9tLXVwIGFwcHJvYWNoLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICB0aGlzLmNoZWNrUGFyYW1ldGVyVHlwZShrZXkpO1xuICAgICAgICBjb25zdCB7IGVudHJ5LCBzaWJsaW5ncyB9ID0gdGhpcy5yZXRyaWV2ZUVudHJ5KGtleSk7XG4gICAgICAgIGlmIChlbnRyeVsxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSBcIiR7a2V5fVwiIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aCA9IGtleVRvUGF0aChrZXkpO1xuICAgICAgICAvLyBEZWxldGVzIHRoZSBlbnRyeS5cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuaGFzaChlbnRyeSk7XG4gICAgICAgIHRoaXMubm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnplcm9Ob2RlO1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgc2libGluZ3MgaXQgZGVsZXRlcyB0aGUgbm9kZXMgb2YgdGhlIHBhdGggYW5kXG4gICAgICAgIC8vIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIHRoZSBuZXcgaGFzaGVzLlxuICAgICAgICBpZiAoc2libGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGVPbGROb2Rlcyhub2RlLCBwYXRoLCBzaWJsaW5ncyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBzaWJsaW5ncyBpcyBub3QgYSBsZWFmIG5vZGUsIGl0IGFkZHMgYWxsIHRoZVxuICAgICAgICAgICAgLy8gbm9kZXMgb2YgdGhlIHBhdGggc3RhcnRpbmcgZnJvbSBhIHplcm8gbm9kZSwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBpdCByZW1vdmVzIHRoZSBsYXN0IG5vbi16ZXJvIHNpYmxpbmdzIGZyb20gdGhlIGBzaWJsaW5nc2BcbiAgICAgICAgICAgIC8vIGFycmF5IGFuZCBpdCBzdGFydHMgZnJvbSBpdCBieSBza2lwcGluZyB0aGUgbGFzdCB6ZXJvIG5vZGVzLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTGVhZihzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLmFkZE5ld05vZGVzKHRoaXMuemVyb05vZGUsIHBhdGgsIHNpYmxpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0U2libGluZyA9IHNpYmxpbmdzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBnZXRJbmRleE9mTGFzdE5vblplcm9FbGVtZW50KHNpYmxpbmdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLmFkZE5ld05vZGVzKGZpcnN0U2libGluZywgcGF0aCwgc2libGluZ3MsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwcm9vZiB0byBwcm92ZSB0aGUgbWVtYmVyc2hpcCBvciB0aGUgbm9uLW1lbWJlcnNoaXBcbiAgICAgKiBvZiBhIHRyZWUgZW50cnkuXG4gICAgICogQHBhcmFtIGtleSBBIGtleSBvZiBhbiBleGlzdGluZyBvciBhIG5vbi1leGlzdGluZyBlbnRyeS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWVtYmVyc2hpcCBvciB0aGUgbm9uLW1lbWJlcnNoaXAgcHJvb2YuXG4gICAgICovXG4gICAgY3JlYXRlUHJvb2Yoa2V5KSB7XG4gICAgICAgIHRoaXMuY2hlY2tQYXJhbWV0ZXJUeXBlKGtleSk7XG4gICAgICAgIGNvbnN0IHsgZW50cnksIG1hdGNoaW5nRW50cnksIHNpYmxpbmdzIH0gPSB0aGlzLnJldHJpZXZlRW50cnkoa2V5KTtcbiAgICAgICAgLy8gSWYgdGhlIGtleSBleGlzdHMgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSBtZW1iZXJzaGlwIHByb29mLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gcmV0dXJucyBhIG5vbi1tZW1iZXJzaGlwIHByb29mIHdpdGggdGhlIG1hdGNoaW5nIGVudHJ5LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICBtYXRjaGluZ0VudHJ5LFxuICAgICAgICAgICAgc2libGluZ3MsXG4gICAgICAgICAgICByb290OiB0aGlzLnJvb3QsXG4gICAgICAgICAgICBtZW1iZXJzaGlwOiAhIWVudHJ5WzFdXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgbWVtYmVyc2hpcCBvciBhIG5vbi1tZW1iZXJzaGlwIHByb29mLlxuICAgICAqIEBwYXJhbSBtZXJrbGVQcm9vZiBUaGUgcHJvb2YgdG8gdmVyaWZ5LlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHByb29mIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmVyaWZ5UHJvb2YobWVya2xlUHJvb2YpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IGEgbWF0Y2hpbmcgZW50cnkgaXQgc2ltcGx5IG9idGFpbnMgdGhlIHJvb3RcbiAgICAgICAgLy8gaGFzaCBieSB1c2luZyB0aGUgc2libGluZ3MgYW5kIHRoZSBwYXRoIG9mIHRoZSBrZXkuXG4gICAgICAgIGlmICghbWVya2xlUHJvb2YubWF0Y2hpbmdFbnRyeSkge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGtleVRvUGF0aChtZXJrbGVQcm9vZi5lbnRyeVswXSk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3QgYW4gZW50cnkgdmFsdWUgdGhlIHByb29mIGlzIGEgbm9uLW1lbWJlcnNoaXAgcHJvb2YsXG4gICAgICAgICAgICAvLyBhbmQgaW4gdGhpcyBjYXNlLCBzaW5jZSB0aGVyZSBpcyBub3QgYSBtYXRjaGluZyBlbnRyeSwgdGhlIG5vZGVcbiAgICAgICAgICAgIC8vIGlzIGEgemVybyBub2RlLiBJZiB0aGVyZSBpcyBhbiBlbnRyeSB2YWx1ZSB0aGUgcHJvb2YgaXMgYVxuICAgICAgICAgICAgLy8gbWVtYmVyc2hpcCBwcm9vZiBhbmQgdGhlIG5vZGUgaXMgdGhlIGhhc2ggb2YgdGhlIGVudHJ5LlxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG1lcmtsZVByb29mLmVudHJ5WzFdICE9PSB1bmRlZmluZWQgPyB0aGlzLmhhc2gobWVya2xlUHJvb2YuZW50cnkpIDogdGhpcy56ZXJvTm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmNhbGN1bGF0ZVJvb3Qobm9kZSwgcGF0aCwgbWVya2xlUHJvb2Yuc2libGluZ3MpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9idGFpbmVkIHJvb3QgaXMgZXF1YWwgdG8gdGhlIHByb29mIHJvb3QsIHRoZW4gdGhlIHByb29mIGlzIHZhbGlkLlxuICAgICAgICAgICAgcmV0dXJuIHJvb3QgPT09IG1lcmtsZVByb29mLnJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBtYXRjaGluZyBlbnRyeSB0aGUgcHJvb2YgaXMgZGVmaW5pdGVseSBhIG5vbi1tZW1iZXJzaGlwXG4gICAgICAgIC8vIHByb29mLiBJbiB0aGlzIGNhc2UgaXQgY2hlY2tzIGlmIHRoZSBtYXRjaGluZyBub2RlIGJlbG9uZ3MgdG8gdGhlIHRyZWVcbiAgICAgICAgLy8gYW5kIHRoZW4gaXQgY2hlY2tzIGlmIHRoZSBudW1iZXIgb2YgdGhlIGZpcnN0IG1hdGNoaW5nIGJpdHMgb2YgdGhlIGtleXNcbiAgICAgICAgLy8gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgdGhlIHNpYmxpbmdzLlxuICAgICAgICBjb25zdCBtYXRjaGluZ1BhdGggPSBrZXlUb1BhdGgobWVya2xlUHJvb2YubWF0Y2hpbmdFbnRyeVswXSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmhhc2gobWVya2xlUHJvb2YubWF0Y2hpbmdFbnRyeSk7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmNhbGN1bGF0ZVJvb3Qobm9kZSwgbWF0Y2hpbmdQYXRoLCBtZXJrbGVQcm9vZi5zaWJsaW5ncyk7XG4gICAgICAgIGlmIChyb290ID09PSBtZXJrbGVQcm9vZi5yb290KSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0ga2V5VG9QYXRoKG1lcmtsZVByb29mLmVudHJ5WzBdKTtcbiAgICAgICAgICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IGNvbW1vbiBiaXRzIG9mIHRoZSB0d28ga2V5czogdGhlXG4gICAgICAgICAgICAvLyBub24tbWVtYmVyIGtleSBhbmQgdGhlIG1hdGNoaW5nIGtleS5cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TWF0Y2hpbmdCaXRzID0gZ2V0Rmlyc3RDb21tb25FbGVtZW50cyhwYXRoLCBtYXRjaGluZ1BhdGgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5vbi1tZW1iZXIga2V5IHdhcyBhIGtleSBvZiBhIHRyZWUgZW50cnksIHRoZSBkZXB0aCBvZiB0aGVcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIG5vZGUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHRoZSBmaXJzdCBjb21tb25cbiAgICAgICAgICAgIC8vIGJpdHMgb2YgdGhlIGtleXMuIFRoZSBkZXB0aCBvZiBhIG5vZGUgY2FuIGJlIGRlZmluZWQgYnkgdGhlIG51bWJlclxuICAgICAgICAgICAgLy8gb2YgaXRzIHNpYmxpbmdzLlxuICAgICAgICAgICAgcmV0dXJuIG1lcmtsZVByb29mLnNpYmxpbmdzLmxlbmd0aCA8PSBmaXJzdE1hdGNoaW5nQml0cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCBlbmFibGVzIHRoZSBjb252ZXJzaW9uIG9mIHRoZSBmdWxsIHRyZWUgc3RydWN0dXJlIGludG8gYSBKU09OIHN0cmluZyxcbiAgICAgKiBmYWNpbGl0YXRpbmcgZnV0dXJlIGltcG9ydHMgb2YgdGhlIHRyZWUuIFRoaXMgYXBwcm9hY2ggaXMgYmVuZWZpY2lhbCBmb3JcbiAgICAgKiBzaGFyaW5nIGFjcm9zcyBuZXR3b3JrcywgYXMgaXQgc2F2ZXMgdGltZSBieSBzdG9yaW5nIHJvb3QgYW5kIHRoZSBtYXAgb2ZcbiAgICAgKiBoYXNoZWQgbm9kZXMgZGlyZWN0bHkgaW5zdGVhZCBvZiByZWNvbXB1dGluZyB0aGVtXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZ2lmaWVkIEpTT04gb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZXhwb3J0KCkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgb2JqLnJvb3QgPSBbdGhpcy5yb290LnRvU3RyaW5nKCldO1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIG9ialtrZXkudG9TdHJpbmcoKV0gPSB2YWx1ZS5tYXAoKHYpID0+IHYudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQgaW1wb3J0cyBhbiBlbnRpcmUgdHJlZSBieSBpbml0aWFsaXppbmcgdGhlIG5vZGVzIGFuZCByb290IHdpdGhvdXQgY2FsY3VsYXRpbmdcbiAgICAgKiBhbnkgaGFzaGVzLiBOb3RlIHRoYXQgaXQgaXMgY3J1Y2lhbCB0byBlbnN1cmUgdGhlIGludGVncml0eSBvZiB0aGUgdHJlZVxuICAgICAqIGJlZm9yZSBvciBhZnRlciBpbXBvcnRpbmcgaXQuXG4gICAgICogVGhlIHRyZWUgbXVzdCBiZSBlbXB0eSBiZWZvcmUgaW1wb3J0aW5nLlxuICAgICAqIEBwYXJhbSBub2RlcyBUaGUgc3RyaW5naWZpZWQgSlNPTiBvZiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBpbXBvcnQoanNvbikge1xuICAgICAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gdGhpcy5iaWdOdW1iZXJzID8gQmlnSW50KHZhbHVlWzBdKSA6IHZhbHVlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgS2V5ID0gdGhpcy5iaWdOdW1iZXJzID8gQmlnSW50KGtleSkgOiBrZXk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmlnTnVtYmVycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBDaGlsZHJlbiA9IHZhbHVlLm1hcCgodikgPT4gQmlnSW50KHYpKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwLnNldChLZXksIENoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5zZXQoS2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZXMgPSBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBhbiBlbnRyeSBpbiB0aGUgdHJlZS4gSWYgdGhlIGtleSBwYXNzZWQgYXMgcGFyYW1ldGVyIGV4aXN0cyBpblxuICAgICAqIHRoZSB0cmVlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgZW50cnksIG90aGVyd2lzZSBpdCByZXR1cm5zIHRoZSBlbnRyeVxuICAgICAqIHdpdGggb25seSB0aGUga2V5LCBhbmQgd2hlbiB0aGVyZSBpcyBhbm90aGVyIGV4aXN0aW5nIGVudHJ5XG4gICAgICogaW4gdGhlIHNhbWUgcGF0aCBpdCByZXR1cm5zIGFsc28gdGhpcyBlbnRyeSBhcyAnbWF0Y2hpbmcgZW50cnknLlxuICAgICAqIEluIGFueSBjYXNlIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSBzaWJsaW5ncyBvZiB0aGUgcGF0aC5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIGVudHJ5IHJlc3BvbnNlLlxuICAgICAqL1xuICAgIHJldHJpZXZlRW50cnkoa2V5KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBrZXlUb1BhdGgoa2V5KTtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgICAgICAgLy8gU3RhcnRzIGZyb20gdGhlIHJvb3QgYW5kIGdvZXMgZG93biBpbnRvIHRoZSB0cmVlIHVudGlsIGl0IGZpbmRzXG4gICAgICAgIC8vIHRoZSBlbnRyeSwgYSB6ZXJvIG5vZGUgb3IgYSBtYXRjaGluZyBlbnRyeS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG5vZGUgPSB0aGlzLnJvb3Q7IG5vZGUgIT09IHRoaXMuemVyb05vZGU7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMubm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcGF0aFtpXTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0aGlyZCBwb3NpdGlvbiBvZiB0aGUgYXJyYXkgaXMgbm90IGVtcHR5IHRoZSBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgLy8gYXJlIGFuIGVudHJ5IG9mIHRoZSB0cmVlLlxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNbMl0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlc1swXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuIGVudHJ5IHdpdGggdGhlIHNhbWUga2V5IHdhcyBmb3VuZCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgcmV0dXJucyBpdCB3aXRoIHRoZSBzaWJsaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZW50cnk6IGNoaWxkTm9kZXMsIHNpYmxpbmdzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBlbnRyeSBmb3VuZCBkb2VzIG5vdCBoYXZlIHRoZSBzYW1lIGtleS4gQnV0IHRoZSBrZXkgb2YgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHBhcnRpY3VsYXIgZW50cnkgbWF0Y2hlcyB0aGUgZmlyc3QgJ2knIGJpdHMgb2YgdGhlIGtleSBwYXNzZWRcbiAgICAgICAgICAgICAgICAvLyBhcyBwYXJhbWV0ZXIgYW5kIGl0IGNhbiBiZSB1c2VmdWwgaW4gc2V2ZXJhbCBmdW5jdGlvbnMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZW50cnk6IFtrZXldLCBtYXRjaGluZ0VudHJ5OiBjaGlsZE5vZGVzLCBzaWJsaW5ncyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiBpdCBnb2VzIGRvd24gaW50byB0aGUgdHJlZSBhbmQgZm9sbG93cyB0aGUgcGF0aCwgaW4gZXZlcnkgc3RlcFxuICAgICAgICAgICAgLy8gYSBub2RlIGlzIGNob3NlbiBiZXR3ZWVuIHRoZSBsZWZ0IGFuZCB0aGUgcmlnaHQgY2hpbGQgbm9kZXMsIGFuZCB0aGVcbiAgICAgICAgICAgIC8vIG9wcG9zaXRlIG5vZGUgaXMgc2F2ZWQgYXMgc2libGluZ3MuXG4gICAgICAgICAgICBub2RlID0gY2hpbGROb2Rlc1tkaXJlY3Rpb25dO1xuICAgICAgICAgICAgc2libGluZ3MucHVzaChjaGlsZE5vZGVzW051bWJlcighZGlyZWN0aW9uKV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBwYXRoIGxlZCB0byBhIHplcm8gbm9kZS5cbiAgICAgICAgcmV0dXJuIHsgZW50cnk6IFtrZXldLCBzaWJsaW5ncyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIG5vZGVzIHdpdGggYSBib3R0b20tdXAgYXBwcm9hY2ggdW50aWwgaXQgcmVhY2hlcyB0aGUgcm9vdCBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHN0YXJ0IGZyb20uXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggb2YgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0gc2libGluZ3MgVGhlIHNpYmxpbmdzIG9mIHRoZSBwYXRoLlxuICAgICAqIEByZXR1cm5zIFRoZSByb290IG5vZGUuXG4gICAgICovXG4gICAgY2FsY3VsYXRlUm9vdChub2RlLCBwYXRoLCBzaWJsaW5ncykge1xuICAgICAgICBmb3IgKGxldCBpID0gc2libGluZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBwYXRoW2ldID8gW3NpYmxpbmdzW2ldLCBub2RlXSA6IFtub2RlLCBzaWJsaW5nc1tpXV07XG4gICAgICAgICAgICBub2RlID0gdGhpcy5oYXNoKGNoaWxkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG5ldyBub2RlcyBpbiB0aGUgdHJlZSB3aXRoIGEgYm90dG9tLXVwIGFwcHJvYWNoIHVudGlsIGl0IHJlYWNoZXMgdGhlIHJvb3Qgbm9kZS5cbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBzdGFydCBmcm9tLlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIHNpYmxpbmdzIFRoZSBzaWJsaW5ncyBvZiB0aGUgcGF0aC5cbiAgICAgKiBAcGFyYW0gaSBUaGUgaW5kZXggdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm9vdCBub2RlLlxuICAgICAqL1xuICAgIGFkZE5ld05vZGVzKG5vZGUsIHBhdGgsIHNpYmxpbmdzLCBpID0gc2libGluZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICBmb3IgKDsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBwYXRoW2ldID8gW3NpYmxpbmdzW2ldLCBub2RlXSA6IFtub2RlLCBzaWJsaW5nc1tpXV07XG4gICAgICAgICAgICBub2RlID0gdGhpcy5oYXNoKGNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5zZXQobm9kZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgbm9kZXMgaW4gdGhlIHRyZWUgd2l0aCBhIGJvdHRvbS11cCBhcHByb2FjaCB1bnRpbCBpdCByZWFjaGVzIHRoZSByb290IG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBvZiB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBzaWJsaW5ncyBUaGUgc2libGluZ3Mgb2YgdGhlIHBhdGguXG4gICAgICovXG4gICAgZGVsZXRlT2xkTm9kZXMobm9kZSwgcGF0aCwgc2libGluZ3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHNpYmxpbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gcGF0aFtpXSA/IFtzaWJsaW5nc1tpXSwgbm9kZV0gOiBbbm9kZSwgc2libGluZ3NbaV1dO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuaGFzaChjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIG5vZGUgaXMgYSBsZWFmIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUgQSBub2RlIG9mIHRoZSB0cmVlLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5vZGUgaXMgYSBsZWFmLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNMZWFmKG5vZGUpIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMubm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICByZXR1cm4gISEoY2hpbGROb2RlcyAmJiBjaGlsZE5vZGVzWzJdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBwYXJhbWV0ZXIgdHlwZS5cbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVyIFRoZSBwYXJhbWV0ZXIgdG8gY2hlY2suXG4gICAgICovXG4gICAgY2hlY2tQYXJhbWV0ZXJUeXBlKHBhcmFtZXRlcikge1xuICAgICAgICBpZiAodGhpcy5iaWdOdW1iZXJzICYmIHR5cGVvZiBwYXJhbWV0ZXIgIT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyYW1ldGVyICR7cGFyYW1ldGVyfSBtdXN0IGJlIGEgYmlnIG51bWJlcmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5iaWdOdW1iZXJzICYmICFjaGVja0hleChwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciAke3BhcmFtZXRlcn0gbXVzdCBiZSBhIGhleGFkZWNpbWFsYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IFNNVCwgY2hlY2tIZXgsIGdldEZpcnN0Q29tbW9uRWxlbWVudHMsIGdldEluZGV4T2ZMYXN0Tm9uWmVyb0VsZW1lbnQsIGhleFRvQmluLCBrZXlUb1BhdGggfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@openpassport/zk-kit-smt/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@openpassport/zk-kit-utils/dist/index.node.js":
/*!********************************************************************!*\
  !*** ./node_modules/@openpassport/zk-kit-utils/dist/index.node.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Buffer: () => (/* reexport safe */ buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer),\n/* harmony export */   F1Field: () => (/* binding */ F1Field),\n/* harmony export */   base64ToBuffer: () => (/* binding */ base64ToBuffer),\n/* harmony export */   base64ToText: () => (/* binding */ base64ToText),\n/* harmony export */   beBigIntToBuffer: () => (/* binding */ beBigIntToBuffer),\n/* harmony export */   beBufferToBigInt: () => (/* binding */ beBufferToBigInt),\n/* harmony export */   bigIntToBuffer: () => (/* binding */ bigIntToBuffer),\n/* harmony export */   bigIntToHexadecimal: () => (/* binding */ bigIntToHexadecimal),\n/* harmony export */   bigNumberishToBigInt: () => (/* binding */ bigNumberishToBigInt),\n/* harmony export */   bigNumberishToBuffer: () => (/* binding */ bigNumberishToBuffer),\n/* harmony export */   bufferToBase64: () => (/* binding */ bufferToBase64),\n/* harmony export */   bufferToBigInt: () => (/* binding */ bufferToBigInt),\n/* harmony export */   bufferToHexadecimal: () => (/* binding */ bufferToHexadecimal),\n/* harmony export */   conversions: () => (/* binding */ conversions),\n/* harmony export */   crypto: () => (/* binding */ crypto_node),\n/* harmony export */   errorHandlers: () => (/* binding */ errorHandlers),\n/* harmony export */   hexadecimalToBigInt: () => (/* binding */ hexadecimalToBigInt),\n/* harmony export */   hexadecimalToBuffer: () => (/* binding */ hexadecimalToBuffer),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isBigInt: () => (/* binding */ isBigInt),\n/* harmony export */   isBigNumber: () => (/* binding */ isBigNumber),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish),\n/* harmony export */   isBuffer: () => (/* binding */ isBuffer),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isHexadecimal: () => (/* binding */ isHexadecimal),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isStringifiedBigInt: () => (/* binding */ isStringifiedBigInt),\n/* harmony export */   isSupportedType: () => (/* binding */ isSupportedType),\n/* harmony export */   isType: () => (/* binding */ isType),\n/* harmony export */   isUint8Array: () => (/* binding */ isUint8Array),\n/* harmony export */   leBigIntToBuffer: () => (/* binding */ leBigIntToBuffer),\n/* harmony export */   leBufferToBigInt: () => (/* binding */ leBufferToBigInt),\n/* harmony export */   packGroth16Proof: () => (/* binding */ packGroth16Proof),\n/* harmony export */   packing: () => (/* binding */ proofPacking),\n/* harmony export */   requireArray: () => (/* binding */ requireArray),\n/* harmony export */   requireBigInt: () => (/* binding */ requireBigInt),\n/* harmony export */   requireBigNumber: () => (/* binding */ requireBigNumber),\n/* harmony export */   requireBigNumberish: () => (/* binding */ requireBigNumberish),\n/* harmony export */   requireBuffer: () => (/* binding */ requireBuffer),\n/* harmony export */   requireDefined: () => (/* binding */ requireDefined),\n/* harmony export */   requireFunction: () => (/* binding */ requireFunction),\n/* harmony export */   requireHexadecimal: () => (/* binding */ requireHexadecimal),\n/* harmony export */   requireNumber: () => (/* binding */ requireNumber),\n/* harmony export */   requireObject: () => (/* binding */ requireObject),\n/* harmony export */   requireString: () => (/* binding */ requireString),\n/* harmony export */   requireStringifiedBigInt: () => (/* binding */ requireStringifiedBigInt),\n/* harmony export */   requireTypes: () => (/* binding */ requireTypes),\n/* harmony export */   requireUint8Array: () => (/* binding */ requireUint8Array),\n/* harmony export */   scalar: () => (/* binding */ scalar),\n/* harmony export */   supportedTypes: () => (/* binding */ supportedTypes),\n/* harmony export */   textToBase64: () => (/* binding */ textToBase64),\n/* harmony export */   typeChecks: () => (/* binding */ typeChecks),\n/* harmony export */   unpackGroth16Proof: () => (/* binding */ unpackGroth16Proof)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/**\n * @module @openpassport/zk-kit-utils\n * @version 0.0.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://www.openpassport.app/}\n*/\n\n\n\n\n/**\n * @module TypeChecks\n * This module provides utility functions to check data types.\n * It defines a set of supported types and includes functions to check if\n * a value is defined and if it matches a supported type. These functions\n * are useful for type checking and validation in the other libraries,\n * enhancing code robustness and reliability.\n */\n/** @internal */\nconst supportedTypes = [\n    \"number\",\n    \"string\",\n    \"function\",\n    \"Array\",\n    \"Uint8Array\",\n    \"Buffer\",\n    \"object\",\n    \"bigint\",\n    \"stringified-bigint\",\n    \"hexadecimal\",\n    \"bignumber\",\n    \"bignumberish\"\n];\n/**\n * Returns true if the value is defined, false otherwise.\n * @param value The value to be checked.\n */\nfunction isDefined(value) {\n    return typeof value !== \"undefined\";\n}\n/**\n * Returns true if the value is a number, false otherwise.\n * @param value The value to be checked.\n */\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n/**\n * Returns true if the value is a string, false otherwise.\n * @param value The value to be checked.\n */\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Returns true if the value is a function, false otherwise.\n * @param value The value to be checked.\n */\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n/**\n * Returns true if the value is an object, false otherwise.\n * Please, note that arrays are also objects in JavaScript.\n * @param value The value to be checked.\n */\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\n/**\n * Returns true if the value is an Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isArray(value) {\n    return isObject(value) && Array.isArray(value);\n}\n/**\n * Returns true if the value is a Uint8Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isUint8Array(value) {\n    return value instanceof Uint8Array;\n}\n/**\n * Returns true if the value is a Buffer instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBuffer(value) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(value);\n}\n/**\n * Returns true if the value is a bigint, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\n/**\n * Checks if the given value is a string that represents a valid bigint.\n * @param value The value to be checked if it's a stringified bigint.\n */\nfunction isStringifiedBigInt(value) {\n    // Check if value is a string first.\n    if (!isString(value)) {\n        return false;\n    }\n    try {\n        // Attempt to convert the string to BigInt.\n        BigInt(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Checks if a string is a valid hexadecimal string representation.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param value The string to be tested.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction isHexadecimal(value, prefix = true) {\n    if (!isString(value)) {\n        return false;\n    }\n    if (prefix) {\n        return /^(0x|0X)[0-9a-fA-F]+$/.test(value);\n    }\n    return /^[0-9a-fA-F]+$/.test(value);\n}\n/**\n * Checks if the given value can be considered as BigNumber.\n * A value is considered a BigNumber if it is a bigint or a string\n * that can be converted to a bigint (via `Bigint(s)`).\n * @param value The value to check.\n */\nfunction isBigNumber(value) {\n    return isBigInt(value) || isStringifiedBigInt(value);\n}\n/**\n * Checks if the given value can be considered as BigNumberish.\n * A value is considered BigNumberish if it meets\n * any of the following conditions: it's a number, a bigint, a string\n * that can be converted to a bigint, a hexadecimal\n * string, or a Buffer object.\n * @param value The value to check.\n */\nfunction isBigNumberish(value) {\n    return (isNumber(value) ||\n        isBigInt(value) ||\n        isStringifiedBigInt(value) ||\n        isHexadecimal(value) ||\n        isBuffer(value) ||\n        isUint8Array(value));\n}\n/**\n * Returns true if the value type is the same as the type passed\n * as the second parameter, false otherwise.\n * @param value\n * @param type The expected type.\n */\nfunction isType(value, type) {\n    switch (type) {\n        case \"number\":\n            return isNumber(value);\n        case \"string\":\n            return isString(value);\n        case \"function\":\n            return isFunction(value);\n        case \"Array\":\n            return isArray(value);\n        case \"Uint8Array\":\n            return isUint8Array(value);\n        case \"Buffer\":\n            return isBuffer(value);\n        case \"object\":\n            return isObject(value);\n        case \"bigint\":\n            return isBigInt(value);\n        case \"stringified-bigint\":\n            return isStringifiedBigInt(value);\n        case \"hexadecimal\":\n            return isHexadecimal(value);\n        case \"bignumber\":\n            return isBigNumber(value);\n        case \"bignumberish\":\n            return isBigNumberish(value);\n        default:\n            return false;\n    }\n}\n/**\n * Returns true if the type is being supported by this utility\n * functions, false otherwise.\n * @param type The type to be checked.\n */\nfunction isSupportedType(type) {\n    return supportedTypes.includes(type);\n}\n\nvar typeChecks = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    isArray: isArray,\n    isBigInt: isBigInt,\n    isBigNumber: isBigNumber,\n    isBigNumberish: isBigNumberish,\n    isBuffer: isBuffer,\n    isDefined: isDefined,\n    isFunction: isFunction,\n    isHexadecimal: isHexadecimal,\n    isNumber: isNumber,\n    isObject: isObject,\n    isString: isString,\n    isStringifiedBigInt: isStringifiedBigInt,\n    isSupportedType: isSupportedType,\n    isType: isType,\n    isUint8Array: isUint8Array,\n    supportedTypes: supportedTypes\n});\n\n/**\n * @module ErrorHandlers\n * This module is designed to provide utility functions for validating\n * function parameters. It includes functions that throw type errors if\n * the parameters do not meet specified criteria, such as being defined,\n * a number, a string, a function, or an array. This module helps ensure\n * that functions receive the correct types of inputs, enhancing code\n * reliability and reducing runtime errors.\n */\n/**\n * @throws Throws a type error if the parameter value has not been defined.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireDefined(parameterValue, parameterName) {\n    if (!isDefined(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not defined`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a number.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireNumber(parameterValue, parameterName) {\n    if (!isNumber(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a number, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a string.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireString(parameterValue, parameterName) {\n    if (!isString(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a string, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a function.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireFunction(parameterValue, parameterName) {\n    if (!isFunction(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a function, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireArray(parameterValue, parameterName) {\n    if (!isArray(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Uint8Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireUint8Array(parameterValue, parameterName) {\n    if (!isUint8Array(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Uint8Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Buffer.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBuffer(parameterValue, parameterName) {\n    if (!isBuffer(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Buffer instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an object.\n * Please, note that arrays are also objects in JavaScript.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireObject(parameterValue, parameterName) {\n    if (!isObject(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an object, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigInt(parameterValue, parameterName) {\n    if (!isBigInt(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bigint, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a stringified bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireStringifiedBigInt(parameterValue, parameterName) {\n    if (!isStringifiedBigInt(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a stringified bigint`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a hexadecimal string.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction requireHexadecimal(parameterValue, parameterName, prefix = true) {\n    if (!isHexadecimal(parameterValue, prefix)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a hexadecimal string`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumber(parameterValue, parameterName) {\n    if (!isBigNumber(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber-ish.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumberish(parameterValue, parameterName) {\n    if (!isBigNumberish(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber-ish`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value type is not part of the list of types.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireTypes(parameterValue, parameterName, types) {\n    for (const type of types) {\n        if (!isSupportedType(type)) {\n            throw new Error(`Type '${type}' is not supported`);\n        }\n    }\n    for (const type of types) {\n        if (isType(parameterValue, type)) {\n            return;\n        }\n    }\n    throw new TypeError(`Parameter '${parameterName}' is none of the following types: ${types.join(\", \")}`);\n}\n\nvar errorHandlers = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    requireArray: requireArray,\n    requireBigInt: requireBigInt,\n    requireBigNumber: requireBigNumber,\n    requireBigNumberish: requireBigNumberish,\n    requireBuffer: requireBuffer,\n    requireDefined: requireDefined,\n    requireFunction: requireFunction,\n    requireHexadecimal: requireHexadecimal,\n    requireNumber: requireNumber,\n    requireObject: requireObject,\n    requireString: requireString,\n    requireStringifiedBigInt: requireStringifiedBigInt,\n    requireTypes: requireTypes,\n    requireUint8Array: requireUint8Array\n});\n\n/**\n * @module Conversions\n * This module provides a collection of utility functions for converting\n * between different numerical formats, particularly focusing on\n * conversions involving bigints, hexadecimals and buffers.\n * The module is structured with clear function naming to indicate\n * the conversion direction (e.g., `bigIntToHexadecimal` for BigInt\n * to hexadecimal, `bufferToBigInt` for buffer to bigint) and employs\n * type checks to ensure the correct handling of various input types.\n * It also includes variations for both big-endian (`be`) and little-endian\n * (`le`) conversions. It is important to note that when there is no prefix,\n * the order of bytes is always big-endian.\n */\n/**\n * Converts a bigint to a hexadecimal string.\n * @param value The bigint value to convert.\n * @returns The hexadecimal representation of the bigint.\n */\nfunction bigIntToHexadecimal(value) {\n    requireBigInt(value, \"value\");\n    let hex = value.toString(16);\n    // Ensure even length.\n    if (hex.length % 2 !== 0) {\n        hex = `0${hex}`;\n    }\n    return hex;\n}\n/**\n * Converts a hexadecimal string to a bigint. The input is interpreted as hexadecimal\n * with or without a '0x' prefix. It uses big-endian byte order.\n * @param value The hexadecimal string to convert.\n * @returns The bigint representation of the hexadecimal string.\n */\nfunction hexadecimalToBigInt(value) {\n    if (!isHexadecimal(value) && !isHexadecimal(value, false)) {\n        throw new TypeError(`Parameter 'value' is not a hexadecimal string`);\n    }\n    // Ensure the hex string starts with '0x'.\n    const formattedHexString = value.startsWith(\"0x\") ? value : `0x${value}`;\n    return BigInt(formattedHexString);\n}\n/**\n * Converts a buffer of bytes to a bigint using big-endian byte order.\n * It accepts 'Buffer' or 'Uint8Array'.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents.\n */\nfunction beBufferToBigInt(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return BigInt(`0x${buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"hex\")}`);\n}\n/**\n * Converts a buffer to a bigint using little-endian byte order.\n * It accepts 'Buffer' or 'Uint8Array'.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents in little-endian.\n */\nfunction leBufferToBigInt(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return BigInt(`0x${buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).reverse().toString(\"hex\")}`);\n}\n/**\n * Converts a buffer to a bigint. Alias for beBufferToBigInt.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents.\n */\nfunction bufferToBigInt(value) {\n    return beBufferToBigInt(value);\n}\n/**\n * Converts a bigint to a buffer and fills with zeros if a valid\n * size (i.e. number of bytes) is specified. If the size is not defined,\n * it gets the size from the given bigint. If the specified size is smaller than\n * the size of the bigint (i.e. `minSize`), an error is thrown.\n * It uses big-endian byte order.\n * @param value The bigint to convert.\n * @param size The number of bytes of the buffer to return.\n * @returns The buffer representation of the bigint.\n */\nfunction beBigIntToBuffer(value, size) {\n    const hex = bigIntToHexadecimal(value);\n    // Calculate the minimum buffer size required to represent 'n' in bytes.\n    // Each hexadecimal character represents 4 bits, so 2 characters are 1 byte.\n    const minSize = Math.ceil(hex.length / 2);\n    if (!size) {\n        size = minSize;\n    }\n    else if (size < minSize) {\n        throw Error(`Size ${size} is too small, need at least ${minSize} bytes`);\n    }\n    // Allocate buffer of the desired size, filled with zeros.\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(size, 0);\n    const fromHex = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\");\n    fromHex.copy(buffer, size - fromHex.length);\n    return buffer;\n}\n/**\n * Converts a bigint to a buffer and fills with zeros if a valid\n * size (i.e. number of bytes) is specified. If the size is not defined,\n * it gets the size from the given bigint. If the specified size is smaller than\n * the size of the bigint (i.e. `minSize`), an error is thrown.\n * It uses little-endian byte order.\n * @param value The bigint to convert.\n * @param size The number of bytes of the buffer to return.\n * @returns The buffer representation of the bigint in little-endian.\n */\nfunction leBigIntToBuffer(value, size) {\n    const hex = bigIntToHexadecimal(value);\n    // Calculate the minimum buffer size required to represent 'n' in bytes.\n    // Each hexadecimal character represents 4 bits, so 2 characters are 1 byte.\n    const minSize = Math.ceil(hex.length / 2);\n    if (!size) {\n        size = minSize;\n    }\n    else if (size < minSize) {\n        throw Error(`Size ${size} is too small, need at least ${minSize} bytes`);\n    }\n    // Allocate buffer of the desired size, filled with zeros.\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(size, 0);\n    const fromHex = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\").reverse();\n    fromHex.copy(buffer, 0);\n    return buffer;\n}\n/**\n * Converts a bigint to a buffer. Alias for beBigIntToBuffer.\n * @param value The bigint to convert.\n * @returns The buffer representation of the bigint.\n */\nfunction bigIntToBuffer(value) {\n    return beBigIntToBuffer(value);\n}\n/**\n * Converts a BigNumberish type to a bigint. If the input is already a bigint,\n * the return value will be the bigint itself, otherwise it will be converted\n * to a bigint using big-endian byte order.\n * @param value The BigNumberish value to convert.\n * @returns The bigint representation of the BigNumberish value.\n */\nfunction bigNumberishToBigInt(value) {\n    requireBigNumberish(value, \"value\");\n    if (isBuffer(value) || isUint8Array(value)) {\n        return bufferToBigInt(value);\n    }\n    return BigInt(value);\n}\n/**\n * Converts a BigNumberish type to a buffer. If the input is already a buffer,\n * the return value will be the buffer itself, otherwise it will be converted\n * to a buffer using big-endian byte order.\n * @param value The BigNumberish value to convert.\n * @returns The buffer representation of the BigNumberish value.\n */\nfunction bigNumberishToBuffer(value) {\n    requireBigNumberish(value, \"value\");\n    if (isBuffer(value) || isUint8Array(value)) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value);\n    }\n    return bigIntToBuffer(bigNumberishToBigInt(value));\n}\n/**\n * Converts an hexadecimal string to a buffer. The hexadecimal string\n * should not start with '0x' or '0X'. It keeps the bytes in the same order.\n * @param value The hexadecimal string to convert.\n * @returns The buffer representation of the hexadecimal string.\n */\nfunction hexadecimalToBuffer(value) {\n    requireHexadecimal(value, \"value\", false);\n    // Ensure even length before converting to buffer.\n    if (value.length % 2 !== 0) {\n        value = `0${value}`;\n    }\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"hex\");\n}\n/**\n * Converts a buffer to a hexadecimal string. It accepts 'Buffer' or 'Uint8Array'.\n * The hexadecimal string will not start with '0x' or '0X'. It keeps the bytes in the same order.\n * @param value The buffer to convert.\n * @returns The converted hexadecimal string.\n */\nfunction bufferToHexadecimal(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"hex\");\n}\n/**\n * Converts bytes to a base64 string. It accepts 'Buffer' or 'Uint8Array'.\n * @param value The bytes to convert.\n * @returns The converted base64 string.\n */\nfunction bufferToBase64(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"base64\");\n}\n/**\n * Converts a base64 string to bytes (i.e. a buffer). This function does not check\n * if the input value is a valid base64 string. If there are unsupported characters\n * they will be ignored.\n * @param value The base64 string to convert.\n * @returns The converted buffer.\n */\nfunction base64ToBuffer(value) {\n    requireString(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"base64\");\n}\n/**\n * Converts text (utf8) to a base64 string.\n * @param value The text to convert.\n * @returns The converted base64 string.\n */\nfunction textToBase64(value) {\n    requireString(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"utf8\").toString(\"base64\");\n}\n/**\n * Converts a base64 string to text (utf8). This function does not check\n * if the input value is a valid base64 string. If there are unsupported characters\n * they could be ignored and the result may be unexpected.\n * @param value The base64 string to convert.\n * @returns The converted text.\n */\nfunction base64ToText(value) {\n    requireString(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"base64\").toString(\"utf8\");\n}\n\nvar conversions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    base64ToBuffer: base64ToBuffer,\n    base64ToText: base64ToText,\n    beBigIntToBuffer: beBigIntToBuffer,\n    beBufferToBigInt: beBufferToBigInt,\n    bigIntToBuffer: bigIntToBuffer,\n    bigIntToHexadecimal: bigIntToHexadecimal,\n    bigNumberishToBigInt: bigNumberishToBigInt,\n    bigNumberishToBuffer: bigNumberishToBuffer,\n    bufferToBase64: bufferToBase64,\n    bufferToBigInt: bufferToBigInt,\n    bufferToHexadecimal: bufferToHexadecimal,\n    hexadecimalToBigInt: hexadecimalToBigInt,\n    hexadecimalToBuffer: hexadecimalToBuffer,\n    leBigIntToBuffer: leBigIntToBuffer,\n    leBufferToBigInt: leBufferToBigInt,\n    textToBase64: textToBase64\n});\n\n/**\n * Generates a random sequence of bytes securely using Node.js's crypto module.\n * @param size The number of bytes to generate.\n * @returns A Uint8Array containing the generated random bytes.\n */\n/* eslint-disable import/prefer-default-export */\nfunction getRandomValues(size) {\n    if (size <= 0)\n        throw Error(`size ${size} is too small, need at least 1`);\n    const buffer = (0,crypto__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(size);\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n}\n\nvar crypto_node = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getRandomValues: getRandomValues\n});\n\n/**\n * @module Scalar\n * This module provides utility functions for performing scalar operations\n * within a field, especially designed to handle operations on bigints.\n * The operations include scalar inversion (`inv`), scalar exponentiation (`pow`),\n * and modular reduction. Functions are carefully implemented to ensure\n * mathematical correctness and efficiency, supporting both positive and\n * negative bigint values. The module aims to provide robust tools for\n * cryptographic calculations and other applications requiring high-precision\n * arithmetic in fields.\n */\n/**\n * Checks if a bigint scalar value is zero.\n * @param a The bigint scalar value to check.\n * @returns True if 'a' is zero, false otherwise.\n */\nfunction isZero(a) {\n    return !a;\n}\n/**\n * Determines whether a bigint scalar value is odd.\n * @param a The bigint scalar value to check.\n * @returns True if 'a' is odd, false if it is even.\n */\nfunction isOdd(a) {\n    return (a & BigInt(1)) === BigInt(1);\n}\n/**\n * Performs a bitwise right shift on a bigint scalar value.\n * This operation is equivalent to dividing by 2^n, but it operates directly\n * on the binary representation, making it efficient for certain types of calculations.\n * @param a The bigint scalar value to shift.\n * @param n The number of bits to shift 'a' by.\n * @returns The result of shifting 'a' right by 'n' bits.\n */\nfunction shiftRight(a, n) {\n    return a >> n;\n}\n/**\n * Multiplies two bigint scalar values.\n * @param a The first bigint scalar value.\n * @param b The second bigint scalar value.\n * @returns The product of 'a' and 'b'.\n */\nfunction mul(a, b) {\n    return a * b;\n}\n/**\n * Compares two bigint scalar values to determine if the first is greater than the second.\n * @param a The first bigint scalar value to compare.\n * @param b The second bigint scalar value to compare.\n * @returns True if 'a' is greater than 'b', false otherwise.\n */\nfunction gt(a, b) {\n    return a > b;\n}\n/**\n * Converts a bigint scalar value into an array of bits, represented as numbers.\n * This function is particularly useful for examining the binary structure of bigints,\n * which can be necessary for bit manipulation and understanding the representation\n * of numbers at a lower level.\n * @param n The bigint scalar value to convert into bits.\n * @returns An array of numbers representing the bits of 'n', starting from the least significant bit.\n */\nfunction bits(n) {\n    const res = [];\n    let E = n;\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        }\n        else {\n            res.push(0);\n        }\n        E >>= BigInt(1);\n    }\n    return res;\n}\n\nvar scalar = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    bits: bits,\n    gt: gt,\n    isOdd: isOdd,\n    isZero: isZero,\n    mul: mul,\n    shiftRight: shiftRight\n});\n\n/**\n * @class F1Field\n * Represents a finite field of order 'order' providing arithmetic operations under modulus.\n * This class includes operations such as addition, subtraction, multiplication, division,\n * and inversion, all performed modulo the field's order. It's designed to work with bigints,\n * supporting large numbers for cryptographic purposes and other applications requiring\n * modular arithmetic.\n * Note that the outputs of the functions will always be within the field if and only if\n * the input values are within the field. Devs need to make sure of that.\n *\n * @property one Represents the scalar value 1 in the field.\n * @property zero Represents the scalar value 0 in the field.\n * @property _order The order of the finite field (i.e., the modulus).\n * @property _half Half the order of the field, used for certain comparisons.\n * @property _negone The scalar value -1 in the field, represented positively.\n */\nclass F1Field {\n    constructor(order) {\n        this.one = 1n;\n        this.zero = 0n;\n        this._order = order;\n        this._half = order >> this.one;\n        this._negone = this._order - this.one;\n    }\n    /**\n     * Ensures a given result falls within the field by applying modular reduction.\n     * This method also handles negative inputs, correctly mapping them into the field.\n     * @param res The result to be normalized to the field.\n     * @returns The equivalent value within the field.\n     */\n    e(res) {\n        res %= this._order;\n        return res < 0 ? res + this._order : res;\n    }\n    /**\n     * Performs modular multiplication of two bigint values within the field.\n     * @param a The first value.\n     * @param b The second value.\n     * @returns The product of 'a' and 'b' modulo the field's order.\n     */\n    mul(a, b) {\n        return (a * b) % this._order;\n    }\n    /**\n     * Subtracts one bigint from another under modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value from which to subtract.\n     * @param b The value to be subtracted.\n     * @returns The difference of 'a' and 'b' modulo the field's order.\n     */\n    sub(a, b) {\n        return a >= b ? a - b : this._order - b + a;\n    }\n    /**\n     * Adds two bigint values together under modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value.\n     * @param b The second value.\n     * @returns The sum of 'a' and 'b' modulo the field's order.\n     */\n    add(a, b) {\n        const res = a + b;\n        return res >= this._order ? res - this._order : res;\n    }\n    /**\n     * Computes the multiplicative inverse of a given value within the field.\n     * This method uses the Extended Euclidean Algorithm to find the inverse,\n     * ensuring the result is always a positive value less than the field's order.\n     * If the input value is zero, which has no inverse, an error is thrown.\n     * @param a The value for which to compute the inverse.\n     * @returns The multiplicative inverse of 'a' modulo the field's order.\n     * @throws if 'a' is zero.\n     */\n    inv(a) {\n        if (a === this.zero) {\n            throw new Error(\"Zero has no inverse\");\n        }\n        let t = this.zero;\n        let r = this._order;\n        let newt = this.one;\n        let newr = a % this._order;\n        while (newr) {\n            const q = r / newr;\n            [t, newt] = [newt, t - q * newt];\n            [r, newr] = [newr, r - q * newr];\n        }\n        if (t < this.zero) {\n            t += this._order;\n        }\n        return t;\n    }\n    /**\n     * Divides one bigint by another within the field by multiplying the first value\n     * by the multiplicative inverse of the second.\n     * @param a The dividend.\n     * @param b The divisor.\n     * @returns The result of the division of 'a' by 'b' modulo the field's order.\n     */\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n    /**\n     * Checks if two bigint values are equal within the context of the field.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' equals 'b', false otherwise.\n     */\n    eq(a, b) {\n        return a === b;\n    }\n    /**\n     * Squares a bigint value within the field.\n     * This is a specific case of multiplication where the value is multiplied by itself,\n     * optimized for performance where applicable.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value to square.\n     * @returns The square of 'a' modulo the field's order.\n     */\n    square(a) {\n        return (a * a) % this._order;\n    }\n    /**\n     * Compares two bigint values to determine if the first is less than the second,\n     * taking into account the field's order for modular comparison.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' is less than 'b', false otherwise.\n     */\n    lt(a, b) {\n        const aa = a > this._half ? a - this._order : a;\n        const bb = b > this._half ? b - this._order : b;\n        return aa < bb;\n    }\n    /**\n     * Compares two bigint values to determine if the first is greater than or equal to the second,\n     * considering the field's modular context.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' is greater than or equal to 'b', false otherwise.\n     */\n    geq(a, b) {\n        const aa = a > this._half ? a - this._order : a;\n        const bb = b > this._half ? b - this._order : b;\n        return aa >= bb;\n    }\n    /**\n     * Computes the negation of a bigint value within the field.\n     * The result is the modular additive inverse that, when added to the original value,\n     * yields zero in the field's modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value to negate.\n     * @returns The negation of 'a' modulo the field's order.\n     */\n    neg(a) {\n        return a ? this._order - a : a;\n    }\n    /**\n     * Checks if a bigint value is zero within the context of the field.\n     * @param a The value to check.\n     * @returns True if 'a' is zero, false otherwise.\n     */\n    isZero(a) {\n        return a === this.zero;\n    }\n    /**\n     * Raises a base to an exponent within the field, efficiently computing\n     * scalar exponentiation using the square-and-multiply algorithm.\n     * Supports both positive and negative exponents through the use of the `inv` method for negatives.\n     * @param base The base to be exponentiated.\n     * @param e The exponent.\n     * @returns The result of raising 'base' to the power 'e' modulo the field's order.\n     */\n    pow(base, e) {\n        if (isZero(e)) {\n            return this.one;\n        }\n        if (e < 0n) {\n            base = this.inv(base);\n            e = -e;\n        }\n        const n = bits(e);\n        if (n.length === 0) {\n            return this.one;\n        }\n        let res = base;\n        for (let i = n.length - 2; i >= 0; i -= 1) {\n            res = this.square(res);\n            if (n[i]) {\n                res = this.mul(res, base);\n            }\n        }\n        return res;\n    }\n}\n\n/**\n * @module ProofPacking\n *\n * This module provides utility functions to pack and unpack\n * various types of objects, making it easier to export or use\n * them externally.\n */\n/**\n * Packs a Snarkjs Groth16 proof into a single list usable as calldata in Solidity (public signals are not included).\n * @param proof The Groth16 proof generated with SnarkJS.\n * @returns Solidity calldata.\n */\nfunction packGroth16Proof(proof) {\n    return [\n        proof.pi_a[0],\n        proof.pi_a[1],\n        proof.pi_b[0][1],\n        proof.pi_b[0][0],\n        proof.pi_b[1][1],\n        proof.pi_b[1][0],\n        proof.pi_c[0],\n        proof.pi_c[1]\n    ];\n}\n/**\n * Unpacks a PackedGroth16Proof Solidity calldata into its original form which is a SnarkJS Groth16 proof.\n * @param proof Solidity calldata.\n * @returns The Groth16 proof compatible with SnarkJS.\n */\nfunction unpackGroth16Proof(proof) {\n    return {\n        pi_a: [proof[0], proof[1]],\n        pi_b: [\n            [proof[3], proof[2]],\n            [proof[5], proof[4]]\n        ],\n        pi_c: [proof[6], proof[7]],\n        protocol: \"groth16\",\n        curve: \"bn128\"\n    };\n}\n\nvar proofPacking = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    packGroth16Proof: packGroth16Proof,\n    unpackGroth16Proof: unpackGroth16Proof\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9wZW5wYXNzcG9ydC96ay1raXQtdXRpbHMvZGlzdC9pbmRleC5ub2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDZ0M7QUFDQTtBQUNLOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYyxvQ0FBb0Msc0JBQXNCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLG9DQUFvQyxzQkFBc0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWMsc0NBQXNDLHNCQUFzQjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLHFDQUFxQyxzQkFBc0I7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWMsb0NBQW9DLHNCQUFzQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYyxvQ0FBb0MsaUJBQWlCO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFNLDZCQUE2QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQU0sdUNBQXVDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU0sOEJBQThCLFNBQVM7QUFDekU7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBTTtBQUN6QixvQkFBb0IsMENBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSw4QkFBOEIsU0FBUztBQUN6RTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFNO0FBQ3pCLG9CQUFvQiwwQ0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQ0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU07QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEMsbUJBQW1CLG1EQUFXO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRXMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NlbGYtd29ya3Nob3AvLi9ub2RlX21vZHVsZXMvQG9wZW5wYXNzcG9ydC96ay1raXQtdXRpbHMvZGlzdC9pbmRleC5ub2RlLmpzPzAwZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEBvcGVucGFzc3BvcnQvemsta2l0LXV0aWxzXG4gKiBAdmVyc2lvbiAwLjAuMVxuICogQGZpbGUgRXNzZW50aWFsIHplcm8ta25vd2xlZGdlIHV0aWxpdHkgbGlicmFyeSBmb3IgSmF2YVNjcmlwdCBkZXZlbG9wZXJzLlxuICogQGNvcHlyaWdodCBFdGhlcmV1bSBGb3VuZGF0aW9uIDIwMjRcbiAqIEBsaWNlbnNlIE1JVFxuICogQHNlZSBbR2l0aHViXXtAbGluayBodHRwczovL3d3dy5vcGVucGFzc3BvcnQuYXBwL31cbiovXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuZXhwb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcblxuLyoqXG4gKiBAbW9kdWxlIFR5cGVDaGVja3NcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHV0aWxpdHkgZnVuY3Rpb25zIHRvIGNoZWNrIGRhdGEgdHlwZXMuXG4gKiBJdCBkZWZpbmVzIGEgc2V0IG9mIHN1cHBvcnRlZCB0eXBlcyBhbmQgaW5jbHVkZXMgZnVuY3Rpb25zIHRvIGNoZWNrIGlmXG4gKiBhIHZhbHVlIGlzIGRlZmluZWQgYW5kIGlmIGl0IG1hdGNoZXMgYSBzdXBwb3J0ZWQgdHlwZS4gVGhlc2UgZnVuY3Rpb25zXG4gKiBhcmUgdXNlZnVsIGZvciB0eXBlIGNoZWNraW5nIGFuZCB2YWxpZGF0aW9uIGluIHRoZSBvdGhlciBsaWJyYXJpZXMsXG4gKiBlbmhhbmNpbmcgY29kZSByb2J1c3RuZXNzIGFuZCByZWxpYWJpbGl0eS5cbiAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3Qgc3VwcG9ydGVkVHlwZXMgPSBbXG4gICAgXCJudW1iZXJcIixcbiAgICBcInN0cmluZ1wiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcIkFycmF5XCIsXG4gICAgXCJVaW50OEFycmF5XCIsXG4gICAgXCJCdWZmZXJcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJzdHJpbmdpZmllZC1iaWdpbnRcIixcbiAgICBcImhleGFkZWNpbWFsXCIsXG4gICAgXCJiaWdudW1iZXJcIixcbiAgICBcImJpZ251bWJlcmlzaFwiXG5dO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGRlZmluZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAqIFBsZWFzZSwgbm90ZSB0aGF0IGFycmF5cyBhcmUgYWxzbyBvYmplY3RzIGluIEphdmFTY3JpcHQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBBcnJheSBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIFVpbnQ4QXJyYXkgaW5zdGFuY2UsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIEJ1ZmZlciBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgYmlnaW50LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQmlnSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIjtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSB2YWxpZCBiaWdpbnQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQgaWYgaXQncyBhIHN0cmluZ2lmaWVkIGJpZ2ludC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSkge1xuICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGEgc3RyaW5nIGZpcnN0LlxuICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gQmlnSW50LlxuICAgICAgICBCaWdJbnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBJZiAncHJlZml4JyBpcyAndHJ1ZScsIHRoZSBzdHJpbmcgbXVzdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJyBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZVxuICogaGV4YWRlY2ltYWwgZGlnaXRzICgwLTksIGEtZiwgQS1GKSwgb3RoZXJ3aXNlIG5vIHByZWZpeCBpcyBleHBlY3RlZC4gJ3ByZWZpeCcgaXMgb3B0aW9uYWwgYW5kXG4gKiBpZiBpdHMgdmFsdWUgaXQgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBpdCB3aWxsIGJlIHNldCB0byAndHJ1ZScgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgc3RyaW5nIHRvIGJlIHRlc3RlZC5cbiAqIEBwYXJhbSBwcmVmaXggQSBib29sZWFuIHRvIGluY2x1ZGUgb3Igbm90IGEgJzB4JyBvciAnMFgnIHByZWZpeC5cbiAqL1xuZnVuY3Rpb24gaXNIZXhhZGVjaW1hbCh2YWx1ZSwgcHJlZml4ID0gdHJ1ZSkge1xuICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gL14oMHh8MFgpWzAtOWEtZkEtRl0rJC8udGVzdCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAvXlswLTlhLWZBLUZdKyQvLnRlc3QodmFsdWUpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBjb25zaWRlcmVkIGFzIEJpZ051bWJlci5cbiAqIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhIEJpZ051bWJlciBpZiBpdCBpcyBhIGJpZ2ludCBvciBhIHN0cmluZ1xuICogdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIGEgYmlnaW50ICh2aWEgYEJpZ2ludChzKWApLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNCaWdOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gaXNCaWdJbnQodmFsdWUpIHx8IGlzU3RyaW5naWZpZWRCaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBjb25zaWRlcmVkIGFzIEJpZ051bWJlcmlzaC5cbiAqIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBCaWdOdW1iZXJpc2ggaWYgaXQgbWVldHNcbiAqIGFueSBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6IGl0J3MgYSBudW1iZXIsIGEgYmlnaW50LCBhIHN0cmluZ1xuICogdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIGEgYmlnaW50LCBhIGhleGFkZWNpbWFsXG4gKiBzdHJpbmcsIG9yIGEgQnVmZmVyIG9iamVjdC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzQmlnTnVtYmVyaXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc051bWJlcih2YWx1ZSkgfHxcbiAgICAgICAgaXNCaWdJbnQodmFsdWUpIHx8XG4gICAgICAgIGlzU3RyaW5naWZpZWRCaWdJbnQodmFsdWUpIHx8XG4gICAgICAgIGlzSGV4YWRlY2ltYWwodmFsdWUpIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fFxuICAgICAgICBpc1VpbnQ4QXJyYXkodmFsdWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSB0eXBlIGlzIHRoZSBzYW1lIGFzIHRoZSB0eXBlIHBhc3NlZFxuICogYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHR5cGUgVGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzVHlwZSh2YWx1ZSwgdHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJVaW50OEFycmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIkJ1ZmZlclwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzQnVmZmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzQmlnSW50KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ2lmaWVkLWJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaW5naWZpZWRCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwiaGV4YWRlY2ltYWxcIjpcbiAgICAgICAgICAgIHJldHVybiBpc0hleGFkZWNpbWFsKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImJpZ251bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzQmlnTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImJpZ251bWJlcmlzaFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzQmlnTnVtYmVyaXNoKHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHlwZSBpcyBiZWluZyBzdXBwb3J0ZWQgYnkgdGhpcyB1dGlsaXR5XG4gKiBmdW5jdGlvbnMsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZFR5cGVzLmluY2x1ZGVzKHR5cGUpO1xufVxuXG52YXIgdHlwZUNoZWNrcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgaXNBcnJheTogaXNBcnJheSxcbiAgICBpc0JpZ0ludDogaXNCaWdJbnQsXG4gICAgaXNCaWdOdW1iZXI6IGlzQmlnTnVtYmVyLFxuICAgIGlzQmlnTnVtYmVyaXNoOiBpc0JpZ051bWJlcmlzaCxcbiAgICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gICAgaXNEZWZpbmVkOiBpc0RlZmluZWQsXG4gICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICBpc0hleGFkZWNpbWFsOiBpc0hleGFkZWNpbWFsLFxuICAgIGlzTnVtYmVyOiBpc051bWJlcixcbiAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgIGlzU3RyaW5naWZpZWRCaWdJbnQ6IGlzU3RyaW5naWZpZWRCaWdJbnQsXG4gICAgaXNTdXBwb3J0ZWRUeXBlOiBpc1N1cHBvcnRlZFR5cGUsXG4gICAgaXNUeXBlOiBpc1R5cGUsXG4gICAgaXNVaW50OEFycmF5OiBpc1VpbnQ4QXJyYXksXG4gICAgc3VwcG9ydGVkVHlwZXM6IHN1cHBvcnRlZFR5cGVzXG59KTtcblxuLyoqXG4gKiBAbW9kdWxlIEVycm9ySGFuZGxlcnNcbiAqIFRoaXMgbW9kdWxlIGlzIGRlc2lnbmVkIHRvIHByb3ZpZGUgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHZhbGlkYXRpbmdcbiAqIGZ1bmN0aW9uIHBhcmFtZXRlcnMuIEl0IGluY2x1ZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93IHR5cGUgZXJyb3JzIGlmXG4gKiB0aGUgcGFyYW1ldGVycyBkbyBub3QgbWVldCBzcGVjaWZpZWQgY3JpdGVyaWEsIHN1Y2ggYXMgYmVpbmcgZGVmaW5lZCxcbiAqIGEgbnVtYmVyLCBhIHN0cmluZywgYSBmdW5jdGlvbiwgb3IgYW4gYXJyYXkuIFRoaXMgbW9kdWxlIGhlbHBzIGVuc3VyZVxuICogdGhhdCBmdW5jdGlvbnMgcmVjZWl2ZSB0aGUgY29ycmVjdCB0eXBlcyBvZiBpbnB1dHMsIGVuaGFuY2luZyBjb2RlXG4gKiByZWxpYWJpbGl0eSBhbmQgcmVkdWNpbmcgcnVudGltZSBlcnJvcnMuXG4gKi9cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaGFzIG5vdCBiZWVuIGRlZmluZWQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZURlZmluZWQocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgZGVmaW5lZGApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVOdW1iZXIocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzTnVtYmVyKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIG51bWJlciwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgcGFyYW1ldGVyVmFsdWV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVN0cmluZyhwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNTdHJpbmcocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgc3RyaW5nLCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVGdW5jdGlvbihwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNGdW5jdGlvbihwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBmdW5jdGlvbiwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgcGFyYW1ldGVyVmFsdWV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYW4gQXJyYXkuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUFycmF5KHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0FycmF5KHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhbiBBcnJheSBpbnN0YW5jZWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgVWludDhBcnJheS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlVWludDhBcnJheShwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNVaW50OEFycmF5KHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIFVpbnQ4QXJyYXkgaW5zdGFuY2VgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIEJ1ZmZlci5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQnVmZmVyKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBCdWZmZXIgaW5zdGFuY2VgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QuXG4gKiBQbGVhc2UsIG5vdGUgdGhhdCBhcnJheXMgYXJlIGFsc28gb2JqZWN0cyBpbiBKYXZhU2NyaXB0LlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVPYmplY3QocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhbiBvYmplY3QsIHJlY2VpdmVkIHR5cGU6ICR7dHlwZW9mIHBhcmFtZXRlclZhbHVlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgYmlnaW50LlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVCaWdJbnQocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQmlnSW50KHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIGJpZ2ludCwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgcGFyYW1ldGVyVmFsdWV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBzdHJpbmdpZmllZCBiaWdpbnQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVN0cmluZ2lmaWVkQmlnSW50KHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc1N0cmluZ2lmaWVkQmlnSW50KHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIHN0cmluZ2lmaWVkIGJpZ2ludGApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogSWYgJ3ByZWZpeCcgaXMgJ3RydWUnLCB0aGUgc3RyaW5nIG11c3Qgc3RhcnQgd2l0aCAnMHgnIG9yICcwWCcgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmVcbiAqIGhleGFkZWNpbWFsIGRpZ2l0cyAoMC05LCBhLWYsIEEtRiksIG90aGVyd2lzZSBubyBwcmVmaXggaXMgZXhwZWN0ZWQuICdwcmVmaXgnIGlzIG9wdGlvbmFsIGFuZFxuICogaWYgaXRzIHZhbHVlIGl0IGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWQgaXQgd2lsbCBiZSBzZXQgdG8gJ3RydWUnIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqIEBwYXJhbSBwcmVmaXggQSBib29sZWFuIHRvIGluY2x1ZGUgb3Igbm90IGEgJzB4JyBvciAnMFgnIHByZWZpeC5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUhleGFkZWNpbWFsKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lLCBwcmVmaXggPSB0cnVlKSB7XG4gICAgaWYgKCFpc0hleGFkZWNpbWFsKHBhcmFtZXRlclZhbHVlLCBwcmVmaXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgaGV4YWRlY2ltYWwgc3RyaW5nYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBiaWdudW1iZXIuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUJpZ051bWJlcihwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNCaWdOdW1iZXIocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgYmlnbnVtYmVyYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBiaWdudW1iZXItaXNoLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVCaWdOdW1iZXJpc2gocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQmlnTnVtYmVyaXNoKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIGJpZ251bWJlci1pc2hgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIHR5cGUgaXMgbm90IHBhcnQgb2YgdGhlIGxpc3Qgb2YgdHlwZXMuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVR5cGVzKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lLCB0eXBlcykge1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICBpZiAoIWlzU3VwcG9ydGVkVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlICcke3R5cGV9JyBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGlmIChpc1R5cGUocGFyYW1ldGVyVmFsdWUsIHR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub25lIG9mIHRoZSBmb2xsb3dpbmcgdHlwZXM6ICR7dHlwZXMuam9pbihcIiwgXCIpfWApO1xufVxuXG52YXIgZXJyb3JIYW5kbGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgcmVxdWlyZUFycmF5OiByZXF1aXJlQXJyYXksXG4gICAgcmVxdWlyZUJpZ0ludDogcmVxdWlyZUJpZ0ludCxcbiAgICByZXF1aXJlQmlnTnVtYmVyOiByZXF1aXJlQmlnTnVtYmVyLFxuICAgIHJlcXVpcmVCaWdOdW1iZXJpc2g6IHJlcXVpcmVCaWdOdW1iZXJpc2gsXG4gICAgcmVxdWlyZUJ1ZmZlcjogcmVxdWlyZUJ1ZmZlcixcbiAgICByZXF1aXJlRGVmaW5lZDogcmVxdWlyZURlZmluZWQsXG4gICAgcmVxdWlyZUZ1bmN0aW9uOiByZXF1aXJlRnVuY3Rpb24sXG4gICAgcmVxdWlyZUhleGFkZWNpbWFsOiByZXF1aXJlSGV4YWRlY2ltYWwsXG4gICAgcmVxdWlyZU51bWJlcjogcmVxdWlyZU51bWJlcixcbiAgICByZXF1aXJlT2JqZWN0OiByZXF1aXJlT2JqZWN0LFxuICAgIHJlcXVpcmVTdHJpbmc6IHJlcXVpcmVTdHJpbmcsXG4gICAgcmVxdWlyZVN0cmluZ2lmaWVkQmlnSW50OiByZXF1aXJlU3RyaW5naWZpZWRCaWdJbnQsXG4gICAgcmVxdWlyZVR5cGVzOiByZXF1aXJlVHlwZXMsXG4gICAgcmVxdWlyZVVpbnQ4QXJyYXk6IHJlcXVpcmVVaW50OEFycmF5XG59KTtcblxuLyoqXG4gKiBAbW9kdWxlIENvbnZlcnNpb25zXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIGNvbGxlY3Rpb24gb2YgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbnZlcnRpbmdcbiAqIGJldHdlZW4gZGlmZmVyZW50IG51bWVyaWNhbCBmb3JtYXRzLCBwYXJ0aWN1bGFybHkgZm9jdXNpbmcgb25cbiAqIGNvbnZlcnNpb25zIGludm9sdmluZyBiaWdpbnRzLCBoZXhhZGVjaW1hbHMgYW5kIGJ1ZmZlcnMuXG4gKiBUaGUgbW9kdWxlIGlzIHN0cnVjdHVyZWQgd2l0aCBjbGVhciBmdW5jdGlvbiBuYW1pbmcgdG8gaW5kaWNhdGVcbiAqIHRoZSBjb252ZXJzaW9uIGRpcmVjdGlvbiAoZS5nLiwgYGJpZ0ludFRvSGV4YWRlY2ltYWxgIGZvciBCaWdJbnRcbiAqIHRvIGhleGFkZWNpbWFsLCBgYnVmZmVyVG9CaWdJbnRgIGZvciBidWZmZXIgdG8gYmlnaW50KSBhbmQgZW1wbG95c1xuICogdHlwZSBjaGVja3MgdG8gZW5zdXJlIHRoZSBjb3JyZWN0IGhhbmRsaW5nIG9mIHZhcmlvdXMgaW5wdXQgdHlwZXMuXG4gKiBJdCBhbHNvIGluY2x1ZGVzIHZhcmlhdGlvbnMgZm9yIGJvdGggYmlnLWVuZGlhbiAoYGJlYCkgYW5kIGxpdHRsZS1lbmRpYW5cbiAqIChgbGVgKSBjb252ZXJzaW9ucy4gSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB3aGVuIHRoZXJlIGlzIG5vIHByZWZpeCxcbiAqIHRoZSBvcmRlciBvZiBieXRlcyBpcyBhbHdheXMgYmlnLWVuZGlhbi5cbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyBhIGJpZ2ludCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYmlnaW50IHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJpZ2ludC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9IZXhhZGVjaW1hbCh2YWx1ZSkge1xuICAgIHJlcXVpcmVCaWdJbnQodmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAvLyBFbnN1cmUgZXZlbiBsZW5ndGguXG4gICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBiaWdpbnQuIFRoZSBpbnB1dCBpcyBpbnRlcnByZXRlZCBhcyBoZXhhZGVjaW1hbFxuICogd2l0aCBvciB3aXRob3V0IGEgJzB4JyBwcmVmaXguIEl0IHVzZXMgYmlnLWVuZGlhbiBieXRlIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBiaWdpbnQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaGV4YWRlY2ltYWxUb0JpZ0ludCh2YWx1ZSkge1xuICAgIGlmICghaXNIZXhhZGVjaW1hbCh2YWx1ZSkgJiYgIWlzSGV4YWRlY2ltYWwodmFsdWUsIGZhbHNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJ3ZhbHVlJyBpcyBub3QgYSBoZXhhZGVjaW1hbCBzdHJpbmdgKTtcbiAgICB9XG4gICAgLy8gRW5zdXJlIHRoZSBoZXggc3RyaW5nIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgY29uc3QgZm9ybWF0dGVkSGV4U3RyaW5nID0gdmFsdWUuc3RhcnRzV2l0aChcIjB4XCIpID8gdmFsdWUgOiBgMHgke3ZhbHVlfWA7XG4gICAgcmV0dXJuIEJpZ0ludChmb3JtYXR0ZWRIZXhTdHJpbmcpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciBvZiBieXRlcyB0byBhIGJpZ2ludCB1c2luZyBiaWctZW5kaWFuIGJ5dGUgb3JkZXIuXG4gKiBJdCBhY2NlcHRzICdCdWZmZXInIG9yICdVaW50OEFycmF5Jy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYnVmZmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYmlnaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBidWZmZXIncyBjb250ZW50cy5cbiAqL1xuZnVuY3Rpb24gYmVCdWZmZXJUb0JpZ0ludCh2YWx1ZSkge1xuICAgIHJlcXVpcmVUeXBlcyh2YWx1ZSwgXCJ2YWx1ZVwiLCBbXCJCdWZmZXJcIiwgXCJVaW50OEFycmF5XCJdKTtcbiAgICByZXR1cm4gQmlnSW50KGAweCR7QnVmZmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKFwiaGV4XCIpfWApO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIGJpZ2ludCB1c2luZyBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gKiBJdCBhY2NlcHRzICdCdWZmZXInIG9yICdVaW50OEFycmF5Jy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYnVmZmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYmlnaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBidWZmZXIncyBjb250ZW50cyBpbiBsaXR0bGUtZW5kaWFuLlxuICovXG5mdW5jdGlvbiBsZUJ1ZmZlclRvQmlnSW50KHZhbHVlKSB7XG4gICAgcmVxdWlyZVR5cGVzKHZhbHVlLCBcInZhbHVlXCIsIFtcIkJ1ZmZlclwiLCBcIlVpbnQ4QXJyYXlcIl0pO1xuICAgIHJldHVybiBCaWdJbnQoYDB4JHtCdWZmZXIuZnJvbSh2YWx1ZSkucmV2ZXJzZSgpLnRvU3RyaW5nKFwiaGV4XCIpfWApO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIGJpZ2ludC4gQWxpYXMgZm9yIGJlQnVmZmVyVG9CaWdJbnQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnVmZmVyJ3MgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvQmlnSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGJlQnVmZmVyVG9CaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJpZ2ludCB0byBhIGJ1ZmZlciBhbmQgZmlsbHMgd2l0aCB6ZXJvcyBpZiBhIHZhbGlkXG4gKiBzaXplIChpLmUuIG51bWJlciBvZiBieXRlcykgaXMgc3BlY2lmaWVkLiBJZiB0aGUgc2l6ZSBpcyBub3QgZGVmaW5lZCxcbiAqIGl0IGdldHMgdGhlIHNpemUgZnJvbSB0aGUgZ2l2ZW4gYmlnaW50LiBJZiB0aGUgc3BlY2lmaWVkIHNpemUgaXMgc21hbGxlciB0aGFuXG4gKiB0aGUgc2l6ZSBvZiB0aGUgYmlnaW50IChpLmUuIGBtaW5TaXplYCksIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEl0IHVzZXMgYmlnLWVuZGlhbiBieXRlIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiaWdpbnQgdG8gY29udmVydC5cbiAqIEBwYXJhbSBzaXplIFRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdGhlIGJ1ZmZlciB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGJlQmlnSW50VG9CdWZmZXIodmFsdWUsIHNpemUpIHtcbiAgICBjb25zdCBoZXggPSBiaWdJbnRUb0hleGFkZWNpbWFsKHZhbHVlKTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1pbmltdW0gYnVmZmVyIHNpemUgcmVxdWlyZWQgdG8gcmVwcmVzZW50ICduJyBpbiBieXRlcy5cbiAgICAvLyBFYWNoIGhleGFkZWNpbWFsIGNoYXJhY3RlciByZXByZXNlbnRzIDQgYml0cywgc28gMiBjaGFyYWN0ZXJzIGFyZSAxIGJ5dGUuXG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMik7XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIHNpemUgPSBtaW5TaXplO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaXplIDwgbWluU2l6ZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgU2l6ZSAke3NpemV9IGlzIHRvbyBzbWFsbCwgbmVlZCBhdCBsZWFzdCAke21pblNpemV9IGJ5dGVzYCk7XG4gICAgfVxuICAgIC8vIEFsbG9jYXRlIGJ1ZmZlciBvZiB0aGUgZGVzaXJlZCBzaXplLCBmaWxsZWQgd2l0aCB6ZXJvcy5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2Moc2l6ZSwgMCk7XG4gICAgY29uc3QgZnJvbUhleCA9IEJ1ZmZlci5mcm9tKGhleCwgXCJoZXhcIik7XG4gICAgZnJvbUhleC5jb3B5KGJ1ZmZlciwgc2l6ZSAtIGZyb21IZXgubGVuZ3RoKTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJpZ2ludCB0byBhIGJ1ZmZlciBhbmQgZmlsbHMgd2l0aCB6ZXJvcyBpZiBhIHZhbGlkXG4gKiBzaXplIChpLmUuIG51bWJlciBvZiBieXRlcykgaXMgc3BlY2lmaWVkLiBJZiB0aGUgc2l6ZSBpcyBub3QgZGVmaW5lZCxcbiAqIGl0IGdldHMgdGhlIHNpemUgZnJvbSB0aGUgZ2l2ZW4gYmlnaW50LiBJZiB0aGUgc3BlY2lmaWVkIHNpemUgaXMgc21hbGxlciB0aGFuXG4gKiB0aGUgc2l6ZSBvZiB0aGUgYmlnaW50IChpLmUuIGBtaW5TaXplYCksIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEl0IHVzZXMgbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiaWdpbnQgdG8gY29udmVydC5cbiAqIEBwYXJhbSBzaXplIFRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdGhlIGJ1ZmZlciB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWdpbnQgaW4gbGl0dGxlLWVuZGlhbi5cbiAqL1xuZnVuY3Rpb24gbGVCaWdJbnRUb0J1ZmZlcih2YWx1ZSwgc2l6ZSkge1xuICAgIGNvbnN0IGhleCA9IGJpZ0ludFRvSGV4YWRlY2ltYWwodmFsdWUpO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSBidWZmZXIgc2l6ZSByZXF1aXJlZCB0byByZXByZXNlbnQgJ24nIGluIGJ5dGVzLlxuICAgIC8vIEVhY2ggaGV4YWRlY2ltYWwgY2hhcmFjdGVyIHJlcHJlc2VudHMgNCBiaXRzLCBzbyAyIGNoYXJhY3RlcnMgYXJlIDEgYnl0ZS5cbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKTtcbiAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgc2l6ZSA9IG1pblNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpemUgPCBtaW5TaXplKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBTaXplICR7c2l6ZX0gaXMgdG9vIHNtYWxsLCBuZWVkIGF0IGxlYXN0ICR7bWluU2l6ZX0gYnl0ZXNgKTtcbiAgICB9XG4gICAgLy8gQWxsb2NhdGUgYnVmZmVyIG9mIHRoZSBkZXNpcmVkIHNpemUsIGZpbGxlZCB3aXRoIHplcm9zLlxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhzaXplLCAwKTtcbiAgICBjb25zdCBmcm9tSGV4ID0gQnVmZmVyLmZyb20oaGV4LCBcImhleFwiKS5yZXZlcnNlKCk7XG4gICAgZnJvbUhleC5jb3B5KGJ1ZmZlciwgMCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgdG8gYSBidWZmZXIuIEFsaWFzIGZvciBiZUJpZ0ludFRvQnVmZmVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiaWdpbnQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJpZ2ludC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gYmVCaWdJbnRUb0J1ZmZlcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgQmlnTnVtYmVyaXNoIHR5cGUgdG8gYSBiaWdpbnQuIElmIHRoZSBpbnB1dCBpcyBhbHJlYWR5IGEgYmlnaW50LFxuICogdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHRoZSBiaWdpbnQgaXRzZWxmLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqIHRvIGEgYmlnaW50IHVzaW5nIGJpZy1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgQmlnTnVtYmVyaXNoIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYmlnaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCaWdOdW1iZXJpc2ggdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaFRvQmlnSW50KHZhbHVlKSB7XG4gICAgcmVxdWlyZUJpZ051bWJlcmlzaCh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpIHx8IGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlclRvQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgQmlnTnVtYmVyaXNoIHR5cGUgdG8gYSBidWZmZXIuIElmIHRoZSBpbnB1dCBpcyBhbHJlYWR5IGEgYnVmZmVyLFxuICogdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHRoZSBidWZmZXIgaXRzZWxmLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqIHRvIGEgYnVmZmVyIHVzaW5nIGJpZy1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgQmlnTnVtYmVyaXNoIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCaWdOdW1iZXJpc2ggdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaFRvQnVmZmVyKHZhbHVlKSB7XG4gICAgcmVxdWlyZUJpZ051bWJlcmlzaCh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpIHx8IGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpZ0ludFRvQnVmZmVyKGJpZ051bWJlcmlzaFRvQmlnSW50KHZhbHVlKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGJ1ZmZlci4gVGhlIGhleGFkZWNpbWFsIHN0cmluZ1xuICogc2hvdWxkIG5vdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJy4gSXQga2VlcHMgdGhlIGJ5dGVzIGluIHRoZSBzYW1lIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaGV4YWRlY2ltYWxUb0J1ZmZlcih2YWx1ZSkge1xuICAgIHJlcXVpcmVIZXhhZGVjaW1hbCh2YWx1ZSwgXCJ2YWx1ZVwiLCBmYWxzZSk7XG4gICAgLy8gRW5zdXJlIGV2ZW4gbGVuZ3RoIGJlZm9yZSBjb252ZXJ0aW5nIHRvIGJ1ZmZlci5cbiAgICBpZiAodmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB2YWx1ZSA9IGAwJHt2YWx1ZX1gO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIFwiaGV4XCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gSXQgYWNjZXB0cyAnQnVmZmVyJyBvciAnVWludDhBcnJheScuXG4gKiBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHdpbGwgbm90IHN0YXJ0IHdpdGggJzB4JyBvciAnMFgnLiBJdCBrZWVwcyB0aGUgYnl0ZXMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvSGV4YWRlY2ltYWwodmFsdWUpIHtcbiAgICByZXF1aXJlVHlwZXModmFsdWUsIFwidmFsdWVcIiwgW1wiQnVmZmVyXCIsIFwiVWludDhBcnJheVwiXSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZyhcImhleFwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYnl0ZXMgdG8gYSBiYXNlNjQgc3RyaW5nLiBJdCBhY2NlcHRzICdCdWZmZXInIG9yICdVaW50OEFycmF5Jy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYnl0ZXMgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgYmFzZTY0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9CYXNlNjQodmFsdWUpIHtcbiAgICByZXF1aXJlVHlwZXModmFsdWUsIFwidmFsdWVcIiwgW1wiQnVmZmVyXCIsIFwiVWludDhBcnJheVwiXSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiYXNlNjQgc3RyaW5nIHRvIGJ5dGVzIChpLmUuIGEgYnVmZmVyKS4gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjaGVja1xuICogaWYgdGhlIGlucHV0IHZhbHVlIGlzIGEgdmFsaWQgYmFzZTY0IHN0cmluZy4gSWYgdGhlcmUgYXJlIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnNcbiAqIHRoZXkgd2lsbCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiYXNlNjQgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gYmFzZTY0VG9CdWZmZXIodmFsdWUpIHtcbiAgICByZXF1aXJlU3RyaW5nKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG59XG4vKipcbiAqIENvbnZlcnRzIHRleHQgKHV0ZjgpIHRvIGEgYmFzZTY0IHN0cmluZy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdGV4dCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBiYXNlNjQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0ZXh0VG9CYXNlNjQodmFsdWUpIHtcbiAgICByZXF1aXJlU3RyaW5nKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJ1dGY4XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2U2NCBzdHJpbmcgdG8gdGV4dCAodXRmOCkuIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY2hlY2tcbiAqIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIGJhc2U2NCBzdHJpbmcuIElmIHRoZXJlIGFyZSB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzXG4gKiB0aGV5IGNvdWxkIGJlIGlnbm9yZWQgYW5kIHRoZSByZXN1bHQgbWF5IGJlIHVuZXhwZWN0ZWQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJhc2U2NCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgdGV4dC5cbiAqL1xuZnVuY3Rpb24gYmFzZTY0VG9UZXh0KHZhbHVlKSB7XG4gICAgcmVxdWlyZVN0cmluZyh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwidXRmOFwiKTtcbn1cblxudmFyIGNvbnZlcnNpb25zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBiYXNlNjRUb0J1ZmZlcjogYmFzZTY0VG9CdWZmZXIsXG4gICAgYmFzZTY0VG9UZXh0OiBiYXNlNjRUb1RleHQsXG4gICAgYmVCaWdJbnRUb0J1ZmZlcjogYmVCaWdJbnRUb0J1ZmZlcixcbiAgICBiZUJ1ZmZlclRvQmlnSW50OiBiZUJ1ZmZlclRvQmlnSW50LFxuICAgIGJpZ0ludFRvQnVmZmVyOiBiaWdJbnRUb0J1ZmZlcixcbiAgICBiaWdJbnRUb0hleGFkZWNpbWFsOiBiaWdJbnRUb0hleGFkZWNpbWFsLFxuICAgIGJpZ051bWJlcmlzaFRvQmlnSW50OiBiaWdOdW1iZXJpc2hUb0JpZ0ludCxcbiAgICBiaWdOdW1iZXJpc2hUb0J1ZmZlcjogYmlnTnVtYmVyaXNoVG9CdWZmZXIsXG4gICAgYnVmZmVyVG9CYXNlNjQ6IGJ1ZmZlclRvQmFzZTY0LFxuICAgIGJ1ZmZlclRvQmlnSW50OiBidWZmZXJUb0JpZ0ludCxcbiAgICBidWZmZXJUb0hleGFkZWNpbWFsOiBidWZmZXJUb0hleGFkZWNpbWFsLFxuICAgIGhleGFkZWNpbWFsVG9CaWdJbnQ6IGhleGFkZWNpbWFsVG9CaWdJbnQsXG4gICAgaGV4YWRlY2ltYWxUb0J1ZmZlcjogaGV4YWRlY2ltYWxUb0J1ZmZlcixcbiAgICBsZUJpZ0ludFRvQnVmZmVyOiBsZUJpZ0ludFRvQnVmZmVyLFxuICAgIGxlQnVmZmVyVG9CaWdJbnQ6IGxlQnVmZmVyVG9CaWdJbnQsXG4gICAgdGV4dFRvQmFzZTY0OiB0ZXh0VG9CYXNlNjRcbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBzZXF1ZW5jZSBvZiBieXRlcyBzZWN1cmVseSB1c2luZyBOb2RlLmpzJ3MgY3J5cHRvIG1vZHVsZS5cbiAqIEBwYXJhbSBzaXplIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyBBIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHJhbmRvbSBieXRlcy5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuZnVuY3Rpb24gZ2V0UmFuZG9tVmFsdWVzKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA8PSAwKVxuICAgICAgICB0aHJvdyBFcnJvcihgc2l6ZSAke3NpemV9IGlzIHRvbyBzbWFsbCwgbmVlZCBhdCBsZWFzdCAxYCk7XG4gICAgY29uc3QgYnVmZmVyID0gcmFuZG9tQnl0ZXMoc2l6ZSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG59XG5cbnZhciBjcnlwdG9fbm9kZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0UmFuZG9tVmFsdWVzOiBnZXRSYW5kb21WYWx1ZXNcbn0pO1xuXG4vKipcbiAqIEBtb2R1bGUgU2NhbGFyXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcGVyZm9ybWluZyBzY2FsYXIgb3BlcmF0aW9uc1xuICogd2l0aGluIGEgZmllbGQsIGVzcGVjaWFsbHkgZGVzaWduZWQgdG8gaGFuZGxlIG9wZXJhdGlvbnMgb24gYmlnaW50cy5cbiAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2NhbGFyIGludmVyc2lvbiAoYGludmApLCBzY2FsYXIgZXhwb25lbnRpYXRpb24gKGBwb3dgKSxcbiAqIGFuZCBtb2R1bGFyIHJlZHVjdGlvbi4gRnVuY3Rpb25zIGFyZSBjYXJlZnVsbHkgaW1wbGVtZW50ZWQgdG8gZW5zdXJlXG4gKiBtYXRoZW1hdGljYWwgY29ycmVjdG5lc3MgYW5kIGVmZmljaWVuY3ksIHN1cHBvcnRpbmcgYm90aCBwb3NpdGl2ZSBhbmRcbiAqIG5lZ2F0aXZlIGJpZ2ludCB2YWx1ZXMuIFRoZSBtb2R1bGUgYWltcyB0byBwcm92aWRlIHJvYnVzdCB0b29scyBmb3JcbiAqIGNyeXB0b2dyYXBoaWMgY2FsY3VsYXRpb25zIGFuZCBvdGhlciBhcHBsaWNhdGlvbnMgcmVxdWlyaW5nIGhpZ2gtcHJlY2lzaW9uXG4gKiBhcml0aG1ldGljIGluIGZpZWxkcy5cbiAqL1xuLyoqXG4gKiBDaGVja3MgaWYgYSBiaWdpbnQgc2NhbGFyIHZhbHVlIGlzIHplcm8uXG4gKiBAcGFyYW0gYSBUaGUgYmlnaW50IHNjYWxhciB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIHplcm8sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNaZXJvKGEpIHtcbiAgICByZXR1cm4gIWE7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIGJpZ2ludCBzY2FsYXIgdmFsdWUgaXMgb2RkLlxuICogQHBhcmFtIGEgVGhlIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyBvZGQsIGZhbHNlIGlmIGl0IGlzIGV2ZW4uXG4gKi9cbmZ1bmN0aW9uIGlzT2RkKGEpIHtcbiAgICByZXR1cm4gKGEgJiBCaWdJbnQoMSkpID09PSBCaWdJbnQoMSk7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYml0d2lzZSByaWdodCBzaGlmdCBvbiBhIGJpZ2ludCBzY2FsYXIgdmFsdWUuXG4gKiBUaGlzIG9wZXJhdGlvbiBpcyBlcXVpdmFsZW50IHRvIGRpdmlkaW5nIGJ5IDJebiwgYnV0IGl0IG9wZXJhdGVzIGRpcmVjdGx5XG4gKiBvbiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uLCBtYWtpbmcgaXQgZWZmaWNpZW50IGZvciBjZXJ0YWluIHR5cGVzIG9mIGNhbGN1bGF0aW9ucy5cbiAqIEBwYXJhbSBhIFRoZSBiaWdpbnQgc2NhbGFyIHZhbHVlIHRvIHNoaWZ0LlxuICogQHBhcmFtIG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0ICdhJyBieS5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2Ygc2hpZnRpbmcgJ2EnIHJpZ2h0IGJ5ICduJyBiaXRzLlxuICovXG5mdW5jdGlvbiBzaGlmdFJpZ2h0KGEsIG4pIHtcbiAgICByZXR1cm4gYSA+PiBuO1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBiaWdpbnQgc2NhbGFyIHZhbHVlcy5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBiaWdpbnQgc2NhbGFyIHZhbHVlLlxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBiaWdpbnQgc2NhbGFyIHZhbHVlLlxuICogQHJldHVybnMgVGhlIHByb2R1Y3Qgb2YgJ2EnIGFuZCAnYicuXG4gKi9cbmZ1bmN0aW9uIG11bChhLCBiKSB7XG4gICAgcmV0dXJuIGEgKiBiO1xufVxuLyoqXG4gKiBDb21wYXJlcyB0d28gYmlnaW50IHNjYWxhciB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaXJzdCBpcyBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBiaWdpbnQgc2NhbGFyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIGdyZWF0ZXIgdGhhbiAnYicsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZ3QoYSwgYikge1xuICAgIHJldHVybiBhID4gYjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgc2NhbGFyIHZhbHVlIGludG8gYW4gYXJyYXkgb2YgYml0cywgcmVwcmVzZW50ZWQgYXMgbnVtYmVycy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgZXhhbWluaW5nIHRoZSBiaW5hcnkgc3RydWN0dXJlIG9mIGJpZ2ludHMsXG4gKiB3aGljaCBjYW4gYmUgbmVjZXNzYXJ5IGZvciBiaXQgbWFuaXB1bGF0aW9uIGFuZCB1bmRlcnN0YW5kaW5nIHRoZSByZXByZXNlbnRhdGlvblxuICogb2YgbnVtYmVycyBhdCBhIGxvd2VyIGxldmVsLlxuICogQHBhcmFtIG4gVGhlIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY29udmVydCBpbnRvIGJpdHMuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgYml0cyBvZiAnbicsIHN0YXJ0aW5nIGZyb20gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC5cbiAqL1xuZnVuY3Rpb24gYml0cyhuKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgbGV0IEUgPSBuO1xuICAgIHdoaWxlIChFKSB7XG4gICAgICAgIGlmIChFICYgQmlnSW50KDEpKSB7XG4gICAgICAgICAgICByZXMucHVzaCgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIEUgPj49IEJpZ0ludCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxudmFyIHNjYWxhciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYml0czogYml0cyxcbiAgICBndDogZ3QsXG4gICAgaXNPZGQ6IGlzT2RkLFxuICAgIGlzWmVybzogaXNaZXJvLFxuICAgIG11bDogbXVsLFxuICAgIHNoaWZ0UmlnaHQ6IHNoaWZ0UmlnaHRcbn0pO1xuXG4vKipcbiAqIEBjbGFzcyBGMUZpZWxkXG4gKiBSZXByZXNlbnRzIGEgZmluaXRlIGZpZWxkIG9mIG9yZGVyICdvcmRlcicgcHJvdmlkaW5nIGFyaXRobWV0aWMgb3BlcmF0aW9ucyB1bmRlciBtb2R1bHVzLlxuICogVGhpcyBjbGFzcyBpbmNsdWRlcyBvcGVyYXRpb25zIHN1Y2ggYXMgYWRkaXRpb24sIHN1YnRyYWN0aW9uLCBtdWx0aXBsaWNhdGlvbiwgZGl2aXNpb24sXG4gKiBhbmQgaW52ZXJzaW9uLCBhbGwgcGVyZm9ybWVkIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci4gSXQncyBkZXNpZ25lZCB0byB3b3JrIHdpdGggYmlnaW50cyxcbiAqIHN1cHBvcnRpbmcgbGFyZ2UgbnVtYmVycyBmb3IgY3J5cHRvZ3JhcGhpYyBwdXJwb3NlcyBhbmQgb3RoZXIgYXBwbGljYXRpb25zIHJlcXVpcmluZ1xuICogbW9kdWxhciBhcml0aG1ldGljLlxuICogTm90ZSB0aGF0IHRoZSBvdXRwdXRzIG9mIHRoZSBmdW5jdGlvbnMgd2lsbCBhbHdheXMgYmUgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZlxuICogdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC4gRGV2cyBuZWVkIHRvIG1ha2Ugc3VyZSBvZiB0aGF0LlxuICpcbiAqIEBwcm9wZXJ0eSBvbmUgUmVwcmVzZW50cyB0aGUgc2NhbGFyIHZhbHVlIDEgaW4gdGhlIGZpZWxkLlxuICogQHByb3BlcnR5IHplcm8gUmVwcmVzZW50cyB0aGUgc2NhbGFyIHZhbHVlIDAgaW4gdGhlIGZpZWxkLlxuICogQHByb3BlcnR5IF9vcmRlciBUaGUgb3JkZXIgb2YgdGhlIGZpbml0ZSBmaWVsZCAoaS5lLiwgdGhlIG1vZHVsdXMpLlxuICogQHByb3BlcnR5IF9oYWxmIEhhbGYgdGhlIG9yZGVyIG9mIHRoZSBmaWVsZCwgdXNlZCBmb3IgY2VydGFpbiBjb21wYXJpc29ucy5cbiAqIEBwcm9wZXJ0eSBfbmVnb25lIFRoZSBzY2FsYXIgdmFsdWUgLTEgaW4gdGhlIGZpZWxkLCByZXByZXNlbnRlZCBwb3NpdGl2ZWx5LlxuICovXG5jbGFzcyBGMUZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihvcmRlcikge1xuICAgICAgICB0aGlzLm9uZSA9IDFuO1xuICAgICAgICB0aGlzLnplcm8gPSAwbjtcbiAgICAgICAgdGhpcy5fb3JkZXIgPSBvcmRlcjtcbiAgICAgICAgdGhpcy5faGFsZiA9IG9yZGVyID4+IHRoaXMub25lO1xuICAgICAgICB0aGlzLl9uZWdvbmUgPSB0aGlzLl9vcmRlciAtIHRoaXMub25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIGEgZ2l2ZW4gcmVzdWx0IGZhbGxzIHdpdGhpbiB0aGUgZmllbGQgYnkgYXBwbHlpbmcgbW9kdWxhciByZWR1Y3Rpb24uXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyBoYW5kbGVzIG5lZ2F0aXZlIGlucHV0cywgY29ycmVjdGx5IG1hcHBpbmcgdGhlbSBpbnRvIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gcmVzIFRoZSByZXN1bHQgdG8gYmUgbm9ybWFsaXplZCB0byB0aGUgZmllbGQuXG4gICAgICogQHJldHVybnMgVGhlIGVxdWl2YWxlbnQgdmFsdWUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKi9cbiAgICBlKHJlcykge1xuICAgICAgICByZXMgJT0gdGhpcy5fb3JkZXI7XG4gICAgICAgIHJldHVybiByZXMgPCAwID8gcmVzICsgdGhpcy5fb3JkZXIgOiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIG1vZHVsYXIgbXVsdGlwbGljYXRpb24gb2YgdHdvIGJpZ2ludCB2YWx1ZXMgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gICAgICogQHBhcmFtIGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvZHVjdCBvZiAnYScgYW5kICdiJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgbXVsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhICogYikgJSB0aGlzLl9vcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIG9uZSBiaWdpbnQgZnJvbSBhbm90aGVyIHVuZGVyIG1vZHVsdXMuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgdmFsdWUgZnJvbSB3aGljaCB0byBzdWJ0cmFjdC5cbiAgICAgKiBAcGFyYW0gYiBUaGUgdmFsdWUgdG8gYmUgc3VidHJhY3RlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGlmZmVyZW5jZSBvZiAnYScgYW5kICdiJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgc3ViKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPj0gYiA/IGEgLSBiIDogdGhpcy5fb3JkZXIgLSBiICsgYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gYmlnaW50IHZhbHVlcyB0b2dldGhlciB1bmRlciBtb2R1bHVzLlxuICAgICAqIEl0IGVuc3VyZXMgdGhlIHJlc3VsdCBpcyB3aXRoaW4gdGhlIGZpZWxkIGlmIGFuZCBvbmx5IGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIGEgVGhlIGZpcnN0IHZhbHVlLlxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gICAgICogQHJldHVybnMgVGhlIHN1bSBvZiAnYScgYW5kICdiJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgYWRkKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYSArIGI7XG4gICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5fb3JkZXIgPyByZXMgLSB0aGlzLl9vcmRlciA6IHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG11bHRpcGxpY2F0aXZlIGludmVyc2Ugb2YgYSBnaXZlbiB2YWx1ZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgdGhlIEV4dGVuZGVkIEV1Y2xpZGVhbiBBbGdvcml0aG0gdG8gZmluZCB0aGUgaW52ZXJzZSxcbiAgICAgKiBlbnN1cmluZyB0aGUgcmVzdWx0IGlzIGFsd2F5cyBhIHBvc2l0aXZlIHZhbHVlIGxlc3MgdGhhbiB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKiBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgemVybywgd2hpY2ggaGFzIG5vIGludmVyc2UsIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICAgKiBAcGFyYW0gYSBUaGUgdmFsdWUgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIGludmVyc2UuXG4gICAgICogQHJldHVybnMgVGhlIG11bHRpcGxpY2F0aXZlIGludmVyc2Ugb2YgJ2EnIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKiBAdGhyb3dzIGlmICdhJyBpcyB6ZXJvLlxuICAgICAqL1xuICAgIGludihhKSB7XG4gICAgICAgIGlmIChhID09PSB0aGlzLnplcm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlplcm8gaGFzIG5vIGludmVyc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQgPSB0aGlzLnplcm87XG4gICAgICAgIGxldCByID0gdGhpcy5fb3JkZXI7XG4gICAgICAgIGxldCBuZXd0ID0gdGhpcy5vbmU7XG4gICAgICAgIGxldCBuZXdyID0gYSAlIHRoaXMuX29yZGVyO1xuICAgICAgICB3aGlsZSAobmV3cikge1xuICAgICAgICAgICAgY29uc3QgcSA9IHIgLyBuZXdyO1xuICAgICAgICAgICAgW3QsIG5ld3RdID0gW25ld3QsIHQgLSBxICogbmV3dF07XG4gICAgICAgICAgICBbciwgbmV3cl0gPSBbbmV3ciwgciAtIHEgKiBuZXdyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCA8IHRoaXMuemVybykge1xuICAgICAgICAgICAgdCArPSB0aGlzLl9vcmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBvbmUgYmlnaW50IGJ5IGFub3RoZXIgd2l0aGluIHRoZSBmaWVsZCBieSBtdWx0aXBseWluZyB0aGUgZmlyc3QgdmFsdWVcbiAgICAgKiBieSB0aGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiB0aGUgc2Vjb25kLlxuICAgICAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZC5cbiAgICAgKiBAcGFyYW0gYiBUaGUgZGl2aXNvci5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbiBvZiAnYScgYnkgJ2InIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBkaXYoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgdGhpcy5pbnYoYikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdHdvIGJpZ2ludCB2YWx1ZXMgYXJlIGVxdWFsIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgZmllbGQuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiAnYScgZXF1YWxzICdiJywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNxdWFyZXMgYSBiaWdpbnQgdmFsdWUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBUaGlzIGlzIGEgc3BlY2lmaWMgY2FzZSBvZiBtdWx0aXBsaWNhdGlvbiB3aGVyZSB0aGUgdmFsdWUgaXMgbXVsdGlwbGllZCBieSBpdHNlbGYsXG4gICAgICogb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZSB3aGVyZSBhcHBsaWNhYmxlLlxuICAgICAqIEl0IGVuc3VyZXMgdGhlIHJlc3VsdCBpcyB3aXRoaW4gdGhlIGZpZWxkIGlmIGFuZCBvbmx5IGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIGEgVGhlIHZhbHVlIHRvIHNxdWFyZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3F1YXJlIG9mICdhJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgc3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIChhICogYSkgJSB0aGlzLl9vcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIGJpZ2ludCB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaXJzdCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZCxcbiAgICAgKiB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBmaWVsZCdzIG9yZGVyIGZvciBtb2R1bGFyIGNvbXBhcmlzb24uXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiAnYScgaXMgbGVzcyB0aGFuICdiJywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGx0KGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWEgPSBhID4gdGhpcy5faGFsZiA/IGEgLSB0aGlzLl9vcmRlciA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gYiA+IHRoaXMuX2hhbGYgPyBiIC0gdGhpcy5fb3JkZXIgOiBiO1xuICAgICAgICByZXR1cm4gYWEgPCBiYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIGJpZ2ludCB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaXJzdCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNlY29uZCxcbiAgICAgKiBjb25zaWRlcmluZyB0aGUgZmllbGQncyBtb2R1bGFyIGNvbnRleHQuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiAnYScgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICdiJywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdlcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFhID0gYSA+IHRoaXMuX2hhbGYgPyBhIC0gdGhpcy5fb3JkZXIgOiBhO1xuICAgICAgICBjb25zdCBiYiA9IGIgPiB0aGlzLl9oYWxmID8gYiAtIHRoaXMuX29yZGVyIDogYjtcbiAgICAgICAgcmV0dXJuIGFhID49IGJiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbmVnYXRpb24gb2YgYSBiaWdpbnQgdmFsdWUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBUaGUgcmVzdWx0IGlzIHRoZSBtb2R1bGFyIGFkZGl0aXZlIGludmVyc2UgdGhhdCwgd2hlbiBhZGRlZCB0byB0aGUgb3JpZ2luYWwgdmFsdWUsXG4gICAgICogeWllbGRzIHplcm8gaW4gdGhlIGZpZWxkJ3MgbW9kdWx1cy5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSB2YWx1ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMgVGhlIG5lZ2F0aW9uIG9mICdhJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgPyB0aGlzLl9vcmRlciAtIGEgOiBhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBiaWdpbnQgdmFsdWUgaXMgemVybyB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyB6ZXJvLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNaZXJvKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IHRoaXMuemVybztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmFpc2VzIGEgYmFzZSB0byBhbiBleHBvbmVudCB3aXRoaW4gdGhlIGZpZWxkLCBlZmZpY2llbnRseSBjb21wdXRpbmdcbiAgICAgKiBzY2FsYXIgZXhwb25lbnRpYXRpb24gdXNpbmcgdGhlIHNxdWFyZS1hbmQtbXVsdGlwbHkgYWxnb3JpdGhtLlxuICAgICAqIFN1cHBvcnRzIGJvdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGV4cG9uZW50cyB0aHJvdWdoIHRoZSB1c2Ugb2YgdGhlIGBpbnZgIG1ldGhvZCBmb3IgbmVnYXRpdmVzLlxuICAgICAqIEBwYXJhbSBiYXNlIFRoZSBiYXNlIHRvIGJlIGV4cG9uZW50aWF0ZWQuXG4gICAgICogQHBhcmFtIGUgVGhlIGV4cG9uZW50LlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgcmFpc2luZyAnYmFzZScgdG8gdGhlIHBvd2VyICdlJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgcG93KGJhc2UsIGUpIHtcbiAgICAgICAgaWYgKGlzWmVybyhlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlIDwgMG4pIHtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmludihiYXNlKTtcbiAgICAgICAgICAgIGUgPSAtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gYml0cyhlKTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcyA9IGJhc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBuLmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICByZXMgPSB0aGlzLnNxdWFyZShyZXMpO1xuICAgICAgICAgICAgaWYgKG5baV0pIHtcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIGJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBtb2R1bGUgUHJvb2ZQYWNraW5nXG4gKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgdG8gcGFjayBhbmQgdW5wYWNrXG4gKiB2YXJpb3VzIHR5cGVzIG9mIG9iamVjdHMsIG1ha2luZyBpdCBlYXNpZXIgdG8gZXhwb3J0IG9yIHVzZVxuICogdGhlbSBleHRlcm5hbGx5LlxuICovXG4vKipcbiAqIFBhY2tzIGEgU25hcmtqcyBHcm90aDE2IHByb29mIGludG8gYSBzaW5nbGUgbGlzdCB1c2FibGUgYXMgY2FsbGRhdGEgaW4gU29saWRpdHkgKHB1YmxpYyBzaWduYWxzIGFyZSBub3QgaW5jbHVkZWQpLlxuICogQHBhcmFtIHByb29mIFRoZSBHcm90aDE2IHByb29mIGdlbmVyYXRlZCB3aXRoIFNuYXJrSlMuXG4gKiBAcmV0dXJucyBTb2xpZGl0eSBjYWxsZGF0YS5cbiAqL1xuZnVuY3Rpb24gcGFja0dyb3RoMTZQcm9vZihwcm9vZikge1xuICAgIHJldHVybiBbXG4gICAgICAgIHByb29mLnBpX2FbMF0sXG4gICAgICAgIHByb29mLnBpX2FbMV0sXG4gICAgICAgIHByb29mLnBpX2JbMF1bMV0sXG4gICAgICAgIHByb29mLnBpX2JbMF1bMF0sXG4gICAgICAgIHByb29mLnBpX2JbMV1bMV0sXG4gICAgICAgIHByb29mLnBpX2JbMV1bMF0sXG4gICAgICAgIHByb29mLnBpX2NbMF0sXG4gICAgICAgIHByb29mLnBpX2NbMV1cbiAgICBdO1xufVxuLyoqXG4gKiBVbnBhY2tzIGEgUGFja2VkR3JvdGgxNlByb29mIFNvbGlkaXR5IGNhbGxkYXRhIGludG8gaXRzIG9yaWdpbmFsIGZvcm0gd2hpY2ggaXMgYSBTbmFya0pTIEdyb3RoMTYgcHJvb2YuXG4gKiBAcGFyYW0gcHJvb2YgU29saWRpdHkgY2FsbGRhdGEuXG4gKiBAcmV0dXJucyBUaGUgR3JvdGgxNiBwcm9vZiBjb21wYXRpYmxlIHdpdGggU25hcmtKUy5cbiAqL1xuZnVuY3Rpb24gdW5wYWNrR3JvdGgxNlByb29mKHByb29mKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGlfYTogW3Byb29mWzBdLCBwcm9vZlsxXV0sXG4gICAgICAgIHBpX2I6IFtcbiAgICAgICAgICAgIFtwcm9vZlszXSwgcHJvb2ZbMl1dLFxuICAgICAgICAgICAgW3Byb29mWzVdLCBwcm9vZls0XV1cbiAgICAgICAgXSxcbiAgICAgICAgcGlfYzogW3Byb29mWzZdLCBwcm9vZls3XV0sXG4gICAgICAgIHByb3RvY29sOiBcImdyb3RoMTZcIixcbiAgICAgICAgY3VydmU6IFwiYm4xMjhcIlxuICAgIH07XG59XG5cbnZhciBwcm9vZlBhY2tpbmcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHBhY2tHcm90aDE2UHJvb2Y6IHBhY2tHcm90aDE2UHJvb2YsXG4gICAgdW5wYWNrR3JvdGgxNlByb29mOiB1bnBhY2tHcm90aDE2UHJvb2Zcbn0pO1xuXG5leHBvcnQgeyBGMUZpZWxkLCBiYXNlNjRUb0J1ZmZlciwgYmFzZTY0VG9UZXh0LCBiZUJpZ0ludFRvQnVmZmVyLCBiZUJ1ZmZlclRvQmlnSW50LCBiaWdJbnRUb0J1ZmZlciwgYmlnSW50VG9IZXhhZGVjaW1hbCwgYmlnTnVtYmVyaXNoVG9CaWdJbnQsIGJpZ051bWJlcmlzaFRvQnVmZmVyLCBidWZmZXJUb0Jhc2U2NCwgYnVmZmVyVG9CaWdJbnQsIGJ1ZmZlclRvSGV4YWRlY2ltYWwsIGNvbnZlcnNpb25zLCBjcnlwdG9fbm9kZSBhcyBjcnlwdG8sIGVycm9ySGFuZGxlcnMsIGhleGFkZWNpbWFsVG9CaWdJbnQsIGhleGFkZWNpbWFsVG9CdWZmZXIsIGlzQXJyYXksIGlzQmlnSW50LCBpc0JpZ051bWJlciwgaXNCaWdOdW1iZXJpc2gsIGlzQnVmZmVyLCBpc0RlZmluZWQsIGlzRnVuY3Rpb24sIGlzSGV4YWRlY2ltYWwsIGlzTnVtYmVyLCBpc09iamVjdCwgaXNTdHJpbmcsIGlzU3RyaW5naWZpZWRCaWdJbnQsIGlzU3VwcG9ydGVkVHlwZSwgaXNUeXBlLCBpc1VpbnQ4QXJyYXksIGxlQmlnSW50VG9CdWZmZXIsIGxlQnVmZmVyVG9CaWdJbnQsIHBhY2tHcm90aDE2UHJvb2YsIHByb29mUGFja2luZyBhcyBwYWNraW5nLCByZXF1aXJlQXJyYXksIHJlcXVpcmVCaWdJbnQsIHJlcXVpcmVCaWdOdW1iZXIsIHJlcXVpcmVCaWdOdW1iZXJpc2gsIHJlcXVpcmVCdWZmZXIsIHJlcXVpcmVEZWZpbmVkLCByZXF1aXJlRnVuY3Rpb24sIHJlcXVpcmVIZXhhZGVjaW1hbCwgcmVxdWlyZU51bWJlciwgcmVxdWlyZU9iamVjdCwgcmVxdWlyZVN0cmluZywgcmVxdWlyZVN0cmluZ2lmaWVkQmlnSW50LCByZXF1aXJlVHlwZXMsIHJlcXVpcmVVaW50OEFycmF5LCBzY2FsYXIsIHN1cHBvcnRlZFR5cGVzLCB0ZXh0VG9CYXNlNjQsIHR5cGVDaGVja3MsIHVucGFja0dyb3RoMTZQcm9vZiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@openpassport/zk-kit-utils/dist/index.node.js\n");

/***/ })

};
;